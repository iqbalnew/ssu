package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserORM struct {
	CreatedAt *time.Time
	DeletedAt *time.Time
	Id        uint64 `gorm:"primary_key;not null"`
	Password  string `gorm:"not null"`
	Role      string `gorm:"default:user;not null"`
	UpdatedAt *time.Time
	Username  string `gorm:"unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type NotificationModuleORM struct {
	CreatedAt    *time.Time
	DeletedAt    *time.Time
	ModuleEvents []*ModuleEventORM `gorm:"foreignkey:NotificationModuleModuleID;association_foreignkey:ModuleID;preload:true"`
	ModuleID     uint64            `gorm:"primary_key;not null"`
	Name         string            `gorm:"type:varchar(255)"`
	UpdatedAt    *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationModuleORM) TableName() string {
	return "notification_modules"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationModule) ToORM(ctx context.Context) (NotificationModuleORM, error) {
	to := NotificationModuleORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationModuleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ModuleID = m.ModuleID
	to.Name = m.Name
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.ModuleEvents {
		if v != nil {
			if tempModuleEvents, cErr := v.ToORM(ctx); cErr == nil {
				to.ModuleEvents = append(to.ModuleEvents, &tempModuleEvents)
			} else {
				return to, cErr
			}
		} else {
			to.ModuleEvents = append(to.ModuleEvents, nil)
		}
	}
	if posthook, ok := interface{}(m).(NotificationModuleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationModuleORM) ToPB(ctx context.Context) (NotificationModule, error) {
	to := NotificationModule{}
	var err error
	if prehook, ok := interface{}(m).(NotificationModuleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ModuleID = m.ModuleID
	to.Name = m.Name
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.ModuleEvents {
		if v != nil {
			if tempModuleEvents, cErr := v.ToPB(ctx); cErr == nil {
				to.ModuleEvents = append(to.ModuleEvents, &tempModuleEvents)
			} else {
				return to, cErr
			}
		} else {
			to.ModuleEvents = append(to.ModuleEvents, nil)
		}
	}
	if posthook, ok := interface{}(m).(NotificationModuleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationModule the arg will be the target, the caller the one being converted from

// NotificationModuleBeforeToORM called before default ToORM code
type NotificationModuleWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationModuleORM) error
}

// NotificationModuleAfterToORM called after default ToORM code
type NotificationModuleWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationModuleORM) error
}

// NotificationModuleBeforeToPB called before default ToPB code
type NotificationModuleWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationModule) error
}

// NotificationModuleAfterToPB called after default ToPB code
type NotificationModuleWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationModule) error
}

type ModuleEventORM struct {
	CreatedAt                  *time.Time
	DeletedAt                  *time.Time
	EventID                    uint64                 `gorm:"primary_key;not null"`
	EventVariables             []*EventVariableORM    `gorm:"foreignkey:ModuleEventEventID;association_foreignkey:EventID;preload:true"`
	Module                     *NotificationModuleORM `gorm:"foreignkey:NotificationModuleModuleID;association_foreignkey:ModuleID"`
	Name                       string                 `gorm:"type:varchar(255)"`
	NotificationModuleModuleID *uint64
	UpdatedAt                  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ModuleEventORM) TableName() string {
	return "module_events"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ModuleEvent) ToORM(ctx context.Context) (ModuleEventORM, error) {
	to := ModuleEventORM{}
	var err error
	if prehook, ok := interface{}(m).(ModuleEventWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EventID = m.EventID
	if m.Module != nil {
		tempModule, err := m.Module.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Module = &tempModule
	}
	to.Name = m.Name
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.EventVariables {
		if v != nil {
			if tempEventVariables, cErr := v.ToORM(ctx); cErr == nil {
				to.EventVariables = append(to.EventVariables, &tempEventVariables)
			} else {
				return to, cErr
			}
		} else {
			to.EventVariables = append(to.EventVariables, nil)
		}
	}
	if posthook, ok := interface{}(m).(ModuleEventWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ModuleEventORM) ToPB(ctx context.Context) (ModuleEvent, error) {
	to := ModuleEvent{}
	var err error
	if prehook, ok := interface{}(m).(ModuleEventWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EventID = m.EventID
	if m.Module != nil {
		tempModule, err := m.Module.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Module = &tempModule
	}
	to.Name = m.Name
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.EventVariables {
		if v != nil {
			if tempEventVariables, cErr := v.ToPB(ctx); cErr == nil {
				to.EventVariables = append(to.EventVariables, &tempEventVariables)
			} else {
				return to, cErr
			}
		} else {
			to.EventVariables = append(to.EventVariables, nil)
		}
	}
	if posthook, ok := interface{}(m).(ModuleEventWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ModuleEvent the arg will be the target, the caller the one being converted from

// ModuleEventBeforeToORM called before default ToORM code
type ModuleEventWithBeforeToORM interface {
	BeforeToORM(context.Context, *ModuleEventORM) error
}

// ModuleEventAfterToORM called after default ToORM code
type ModuleEventWithAfterToORM interface {
	AfterToORM(context.Context, *ModuleEventORM) error
}

// ModuleEventBeforeToPB called before default ToPB code
type ModuleEventWithBeforeToPB interface {
	BeforeToPB(context.Context, *ModuleEvent) error
}

// ModuleEventAfterToPB called after default ToPB code
type ModuleEventWithAfterToPB interface {
	AfterToPB(context.Context, *ModuleEvent) error
}

type EventVariableORM struct {
	ColumnName         string `gorm:"type:varchar(255)"`
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	Event              *ModuleEventORM `gorm:"foreignkey:ModuleEventEventID;association_foreignkey:EventID"`
	ModuleEventEventID *uint64
	Name               string `gorm:"type:varchar(255)"`
	Table              string `gorm:"type:varchar(255)"`
	UpdatedAt          *time.Time
	VariableID         uint64 `gorm:"primary_key;not null"`
}

// TableName overrides the default tablename generated by GORM
func (EventVariableORM) TableName() string {
	return "event_variables"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EventVariable) ToORM(ctx context.Context) (EventVariableORM, error) {
	to := EventVariableORM{}
	var err error
	if prehook, ok := interface{}(m).(EventVariableWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.VariableID = m.VariableID
	if m.Event != nil {
		tempEvent, err := m.Event.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.Name = m.Name
	to.Table = m.Table
	to.ColumnName = m.ColumnName
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(EventVariableWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EventVariableORM) ToPB(ctx context.Context) (EventVariable, error) {
	to := EventVariable{}
	var err error
	if prehook, ok := interface{}(m).(EventVariableWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.VariableID = m.VariableID
	if m.Event != nil {
		tempEvent, err := m.Event.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.Name = m.Name
	to.Table = m.Table
	to.ColumnName = m.ColumnName
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(EventVariableWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EventVariable the arg will be the target, the caller the one being converted from

// EventVariableBeforeToORM called before default ToORM code
type EventVariableWithBeforeToORM interface {
	BeforeToORM(context.Context, *EventVariableORM) error
}

// EventVariableAfterToORM called after default ToORM code
type EventVariableWithAfterToORM interface {
	AfterToORM(context.Context, *EventVariableORM) error
}

// EventVariableBeforeToPB called before default ToPB code
type EventVariableWithBeforeToPB interface {
	BeforeToPB(context.Context, *EventVariable) error
}

// EventVariableAfterToPB called after default ToPB code
type EventVariableWithAfterToPB interface {
	AfterToPB(context.Context, *EventVariable) error
}

type NotificationORM struct {
	Code               string `gorm:"type:varchar(255)"`
	CompanyID          uint64
	CreatedAt          *time.Time
	CreatedByID        uint64
	DeletedAt          *time.Time
	DeletedByID        uint64
	Description        string          `gorm:"type:varchar(255)"`
	Event              *ModuleEventORM `gorm:"foreignkey:ModuleEventEventID;association_foreignkey:EventID"`
	ModuleEventEventID *uint64
	NotificationEmail  *NotificationEmailORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationID     uint64                `gorm:"primary_key;not null"`
	NotificationSms    *NotificationSMSORM   `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	UpdatedAt          *time.Time
	UpdatedByID        uint64
}

// TableName overrides the default tablename generated by GORM
func (NotificationORM) TableName() string {
	return "notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Notification) ToORM(ctx context.Context) (NotificationORM, error) {
	to := NotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationID = m.NotificationID
	to.CompanyID = m.CompanyID
	if m.Event != nil {
		tempEvent, err := m.Event.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.Code = m.Code
	to.Description = m.Description
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if m.NotificationSms != nil {
		tempNotificationSms, err := m.NotificationSms.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSms = &tempNotificationSms
	}
	if m.NotificationEmail != nil {
		tempNotificationEmail, err := m.NotificationEmail.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationEmail = &tempNotificationEmail
	}
	if posthook, ok := interface{}(m).(NotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationORM) ToPB(ctx context.Context) (Notification, error) {
	to := Notification{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationID = m.NotificationID
	to.CompanyID = m.CompanyID
	if m.Event != nil {
		tempEvent, err := m.Event.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.Code = m.Code
	to.Description = m.Description
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if m.NotificationSms != nil {
		tempNotificationSms, err := m.NotificationSms.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSms = &tempNotificationSms
	}
	if m.NotificationEmail != nil {
		tempNotificationEmail, err := m.NotificationEmail.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationEmail = &tempNotificationEmail
	}
	if posthook, ok := interface{}(m).(NotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Notification the arg will be the target, the caller the one being converted from

// NotificationBeforeToORM called before default ToORM code
type NotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationORM) error
}

// NotificationAfterToORM called after default ToORM code
type NotificationWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationORM) error
}

// NotificationBeforeToPB called before default ToPB code
type NotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Notification) error
}

// NotificationAfterToPB called after default ToPB code
type NotificationWithAfterToPB interface {
	AfterToPB(context.Context, *Notification) error
}

type NotificationSMSORM struct {
	Content                    string `gorm:"type:text"`
	CreatedAt                  *time.Time
	CreatedByID                uint64
	DeletedAt                  *time.Time
	DeletedByID                uint64
	Notification               *NotificationORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationNotificationID *uint64
	SmsDeliveryID              uint64 `gorm:"primary_key;not null"`
	UpdatedAt                  *time.Time
	UpdatedByID                uint64
}

// TableName overrides the default tablename generated by GORM
func (NotificationSMSORM) TableName() string {
	return "notification_sms"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationSMS) ToORM(ctx context.Context) (NotificationSMSORM, error) {
	to := NotificationSMSORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSMSWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SmsDeliveryID = m.SmsDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Content = m.Content
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(NotificationSMSWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationSMSORM) ToPB(ctx context.Context) (NotificationSMS, error) {
	to := NotificationSMS{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSMSWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SmsDeliveryID = m.SmsDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Content = m.Content
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(NotificationSMSWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationSMS the arg will be the target, the caller the one being converted from

// NotificationSMSBeforeToORM called before default ToORM code
type NotificationSMSWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationSMSORM) error
}

// NotificationSMSAfterToORM called after default ToORM code
type NotificationSMSWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationSMSORM) error
}

// NotificationSMSBeforeToPB called before default ToPB code
type NotificationSMSWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationSMS) error
}

// NotificationSMSAfterToPB called after default ToPB code
type NotificationSMSWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationSMS) error
}

type NotificationEmailORM struct {
	Body                       string `gorm:"type:text"`
	CreatedAt                  *time.Time
	CreatedByID                uint64
	DeletedAt                  *time.Time
	DeletedByID                uint64
	EmailDeliveryID            uint64           `gorm:"primary_key;not null"`
	Notification               *NotificationORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationNotificationID *uint64
	Subject                    string `gorm:"type:text"`
	UpdatedAt                  *time.Time
	UpdatedByID                uint64
}

// TableName overrides the default tablename generated by GORM
func (NotificationEmailORM) TableName() string {
	return "notification_emails"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationEmail) ToORM(ctx context.Context) (NotificationEmailORM, error) {
	to := NotificationEmailORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationEmailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EmailDeliveryID = m.EmailDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Subject = m.Subject
	to.Body = m.Body
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(NotificationEmailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationEmailORM) ToPB(ctx context.Context) (NotificationEmail, error) {
	to := NotificationEmail{}
	var err error
	if prehook, ok := interface{}(m).(NotificationEmailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EmailDeliveryID = m.EmailDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Subject = m.Subject
	to.Body = m.Body
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(NotificationEmailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationEmail the arg will be the target, the caller the one being converted from

// NotificationEmailBeforeToORM called before default ToORM code
type NotificationEmailWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationEmailORM) error
}

// NotificationEmailAfterToORM called after default ToORM code
type NotificationEmailWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationEmailORM) error
}

// NotificationEmailBeforeToPB called before default ToPB code
type NotificationEmailWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationEmail) error
}

// NotificationEmailAfterToPB called after default ToPB code
type NotificationEmailWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationEmail) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateNotificationModule executes a basic gorm create call
func DefaultCreateNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationModuleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.ModuleID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationModuleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationModuleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationModuleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationModuleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.ModuleID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationModuleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationModuleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationModuleSet(ctx context.Context, in []*NotificationModule, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.ModuleID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.ModuleID)
	}
	if hook, ok := (interface{}(&NotificationModuleORM{})).(NotificationModuleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("module_id in (?)", keys).Delete(&NotificationModuleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationModuleORM{})).(NotificationModuleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationModuleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationModule, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationModule, *gorm.DB) error
}

// DefaultStrictUpdateNotificationModule clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationModule")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationModuleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("module_id=?", ormObj.ModuleID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterModuleEvents := ModuleEventORM{}
	if ormObj.ModuleID == 0 {
		return nil, errors.EmptyIdError
	}
	filterModuleEvents.NotificationModuleModuleID = new(uint64)
	*filterModuleEvents.NotificationModuleModuleID = ormObj.ModuleID
	if err = db.Where(filterModuleEvents).Delete(ModuleEventORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationModuleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationModule executes a basic gorm update call with patch behavior
func DefaultPatchNotificationModule(ctx context.Context, in *NotificationModule, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationModule
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationModuleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationModuleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationModule(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationModuleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationModule(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationModuleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationModuleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationModule executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationModule(ctx context.Context, objects []*NotificationModule, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationModule, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationModule, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationModule(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationModule patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationModule(ctx context.Context, patchee *NotificationModule, patcher *NotificationModule, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationModule, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"ModuleID" {
			patchee.ModuleID = patcher.ModuleID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"ModuleEvents" {
			patchee.ModuleEvents = patcher.ModuleEvents
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationModule executes a gorm list call
func DefaultListNotificationModule(ctx context.Context, db *gorm.DB) ([]*NotificationModule, error) {
	in := NotificationModule{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationModuleORM{}, &NotificationModule{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("module_id")
	ormResponse := []NotificationModuleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationModule{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationModuleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationModuleORM) error
}

// DefaultCreateModuleEvent executes a basic gorm create call
func DefaultCreateModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ModuleEventORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.EventID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ModuleEventORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ModuleEventORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ModuleEventORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ModuleEventORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.EventID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ModuleEventORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ModuleEventORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleEventSet(ctx context.Context, in []*ModuleEvent, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.EventID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.EventID)
	}
	if hook, ok := (interface{}(&ModuleEventORM{})).(ModuleEventORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("event_id in (?)", keys).Delete(&ModuleEventORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ModuleEventORM{})).(ModuleEventORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ModuleEventORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ModuleEvent, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ModuleEvent, *gorm.DB) error
}

// DefaultStrictUpdateModuleEvent clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateModuleEvent")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ModuleEventORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("event_id=?", ormObj.EventID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEventVariables := EventVariableORM{}
	if ormObj.EventID == 0 {
		return nil, errors.EmptyIdError
	}
	filterEventVariables.ModuleEventEventID = new(uint64)
	*filterEventVariables.ModuleEventEventID = ormObj.EventID
	if err = db.Where(filterEventVariables).Delete(EventVariableORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ModuleEventORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchModuleEvent executes a basic gorm update call with patch behavior
func DefaultPatchModuleEvent(ctx context.Context, in *ModuleEvent, updateMask *field_mask.FieldMask, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ModuleEvent
	var err error
	if hook, ok := interface{}(&pbObj).(ModuleEventWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(ModuleEventWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskModuleEvent(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ModuleEventWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateModuleEvent(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ModuleEventWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ModuleEventWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetModuleEvent executes a bulk gorm update call with patch behavior
func DefaultPatchSetModuleEvent(ctx context.Context, objects []*ModuleEvent, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ModuleEvent, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ModuleEvent, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchModuleEvent(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskModuleEvent patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskModuleEvent(ctx context.Context, patchee *ModuleEvent, patcher *ModuleEvent, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ModuleEvent, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModule bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"EventID" {
			patchee.EventID = patcher.EventID
			continue
		}
		if !updatedModule && strings.HasPrefix(f, prefix+"Module.") {
			updatedModule = true
			if patcher.Module == nil {
				patchee.Module = nil
				continue
			}
			if patchee.Module == nil {
				patchee.Module = &NotificationModule{}
			}
			if o, err := DefaultApplyFieldMaskNotificationModule(ctx, patchee.Module, patcher.Module, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Module.", db); err != nil {
				return nil, err
			} else {
				patchee.Module = o
			}
			continue
		}
		if f == prefix+"Module" {
			updatedModule = true
			patchee.Module = patcher.Module
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"EventVariables" {
			patchee.EventVariables = patcher.EventVariables
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListModuleEvent executes a gorm list call
func DefaultListModuleEvent(ctx context.Context, db *gorm.DB) ([]*ModuleEvent, error) {
	in := ModuleEvent{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ModuleEventORM{}, &ModuleEvent{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("event_id")
	ormResponse := []ModuleEventORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ModuleEvent{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ModuleEventORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ModuleEventORM) error
}

// DefaultCreateEventVariable executes a basic gorm create call
func DefaultCreateEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EventVariableORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.VariableID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EventVariableORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EventVariableORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EventVariableORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EventVariableORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.VariableID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EventVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EventVariableORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEventVariableSet(ctx context.Context, in []*EventVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.VariableID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.VariableID)
	}
	if hook, ok := (interface{}(&EventVariableORM{})).(EventVariableORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("variable_id in (?)", keys).Delete(&EventVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EventVariableORM{})).(EventVariableORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EventVariableORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EventVariable, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EventVariable, *gorm.DB) error
}

// DefaultStrictUpdateEventVariable clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEventVariable")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EventVariableORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("variable_id=?", ormObj.VariableID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EventVariableORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEventVariable executes a basic gorm update call with patch behavior
func DefaultPatchEventVariable(ctx context.Context, in *EventVariable, updateMask *field_mask.FieldMask, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EventVariable
	var err error
	if hook, ok := interface{}(&pbObj).(EventVariableWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(EventVariableWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEventVariable(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EventVariableWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEventVariable(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EventVariableWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EventVariableWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EventVariableWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EventVariableWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EventVariableWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEventVariable executes a bulk gorm update call with patch behavior
func DefaultPatchSetEventVariable(ctx context.Context, objects []*EventVariable, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EventVariable, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EventVariable, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEventVariable(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEventVariable patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEventVariable(ctx context.Context, patchee *EventVariable, patcher *EventVariable, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EventVariable, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedEvent bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"VariableID" {
			patchee.VariableID = patcher.VariableID
			continue
		}
		if !updatedEvent && strings.HasPrefix(f, prefix+"Event.") {
			updatedEvent = true
			if patcher.Event == nil {
				patchee.Event = nil
				continue
			}
			if patchee.Event == nil {
				patchee.Event = &ModuleEvent{}
			}
			if o, err := DefaultApplyFieldMaskModuleEvent(ctx, patchee.Event, patcher.Event, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Event.", db); err != nil {
				return nil, err
			} else {
				patchee.Event = o
			}
			continue
		}
		if f == prefix+"Event" {
			updatedEvent = true
			patchee.Event = patcher.Event
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Table" {
			patchee.Table = patcher.Table
			continue
		}
		if f == prefix+"ColumnName" {
			patchee.ColumnName = patcher.ColumnName
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEventVariable executes a gorm list call
func DefaultListEventVariable(ctx context.Context, db *gorm.DB) ([]*EventVariable, error) {
	in := EventVariable{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EventVariableORM{}, &EventVariable{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("variable_id")
	ormResponse := []EventVariableORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EventVariable{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EventVariableORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EventVariableORM) error
}

// DefaultCreateNotification executes a basic gorm create call
func DefaultCreateNotification(ctx context.Context, in *Notification, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotification(ctx context.Context, in *Notification, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotification(ctx context.Context, in *Notification, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.NotificationID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSet(ctx context.Context, in []*Notification, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.NotificationID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.NotificationID)
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("notification_id in (?)", keys).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Notification, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Notification, *gorm.DB) error
}

// DefaultStrictUpdateNotification clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotification(ctx context.Context, in *Notification, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("notification_id=?", ormObj.NotificationID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotificationEmail := NotificationEmailORM{}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationEmail.NotificationNotificationID = new(uint64)
	*filterNotificationEmail.NotificationNotificationID = ormObj.NotificationID
	if err = db.Where(filterNotificationEmail).Delete(NotificationEmailORM{}).Error; err != nil {
		return nil, err
	}
	filterNotificationSms := NotificationSMSORM{}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationSms.NotificationNotificationID = new(uint64)
	*filterNotificationSms.NotificationNotificationID = ormObj.NotificationID
	if err = db.Where(filterNotificationSms).Delete(NotificationSMSORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotification executes a basic gorm update call with patch behavior
func DefaultPatchNotification(ctx context.Context, in *Notification, updateMask *field_mask.FieldMask, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Notification
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotification(ctx context.Context, objects []*Notification, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Notification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Notification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotification(ctx context.Context, patchee *Notification, patcher *Notification, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Notification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedEvent bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	var updatedNotificationSms bool
	var updatedNotificationEmail bool
	for i, f := range updateMask.Paths {
		if f == prefix+"NotificationID" {
			patchee.NotificationID = patcher.NotificationID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if !updatedEvent && strings.HasPrefix(f, prefix+"Event.") {
			updatedEvent = true
			if patcher.Event == nil {
				patchee.Event = nil
				continue
			}
			if patchee.Event == nil {
				patchee.Event = &ModuleEvent{}
			}
			if o, err := DefaultApplyFieldMaskModuleEvent(ctx, patchee.Event, patcher.Event, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Event.", db); err != nil {
				return nil, err
			} else {
				patchee.Event = o
			}
			continue
		}
		if f == prefix+"Event" {
			updatedEvent = true
			patchee.Event = patcher.Event
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if !updatedNotificationSms && strings.HasPrefix(f, prefix+"NotificationSms.") {
			updatedNotificationSms = true
			if patcher.NotificationSms == nil {
				patchee.NotificationSms = nil
				continue
			}
			if patchee.NotificationSms == nil {
				patchee.NotificationSms = &NotificationSMS{}
			}
			if o, err := DefaultApplyFieldMaskNotificationSMS(ctx, patchee.NotificationSms, patcher.NotificationSms, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationSms.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationSms = o
			}
			continue
		}
		if f == prefix+"NotificationSms" {
			updatedNotificationSms = true
			patchee.NotificationSms = patcher.NotificationSms
			continue
		}
		if !updatedNotificationEmail && strings.HasPrefix(f, prefix+"NotificationEmail.") {
			updatedNotificationEmail = true
			if patcher.NotificationEmail == nil {
				patchee.NotificationEmail = nil
				continue
			}
			if patchee.NotificationEmail == nil {
				patchee.NotificationEmail = &NotificationEmail{}
			}
			if o, err := DefaultApplyFieldMaskNotificationEmail(ctx, patchee.NotificationEmail, patcher.NotificationEmail, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationEmail.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationEmail = o
			}
			continue
		}
		if f == prefix+"NotificationEmail" {
			updatedNotificationEmail = true
			patchee.NotificationEmail = patcher.NotificationEmail
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotification executes a gorm list call
func DefaultListNotification(ctx context.Context, db *gorm.DB) ([]*Notification, error) {
	in := Notification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationORM{}, &Notification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("notification_id")
	ormResponse := []NotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Notification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationORM) error
}

// DefaultCreateNotificationSMS executes a basic gorm create call
func DefaultCreateNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSMSORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.SmsDeliveryID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationSMSORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationSMSORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationSMSORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSMSORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.SmsDeliveryID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationSMSORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationSMSORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSMSSet(ctx context.Context, in []*NotificationSMS, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.SmsDeliveryID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.SmsDeliveryID)
	}
	if hook, ok := (interface{}(&NotificationSMSORM{})).(NotificationSMSORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("sms_delivery_id in (?)", keys).Delete(&NotificationSMSORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationSMSORM{})).(NotificationSMSORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationSMSORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationSMS, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationSMS, *gorm.DB) error
}

// DefaultStrictUpdateNotificationSMS clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationSMS")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationSMSORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("sms_delivery_id=?", ormObj.SmsDeliveryID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationSMSORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationSMS executes a basic gorm update call with patch behavior
func DefaultPatchNotificationSMS(ctx context.Context, in *NotificationSMS, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationSMS
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationSMSWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationSMSWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationSMS(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationSMSWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationSMS(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationSMSWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationSMSWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationSMS executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationSMS(ctx context.Context, objects []*NotificationSMS, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationSMS, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationSMS, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationSMS(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationSMS patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationSMS(ctx context.Context, patchee *NotificationSMS, patcher *NotificationSMS, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationSMS, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotification bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"SmsDeliveryID" {
			patchee.SmsDeliveryID = patcher.SmsDeliveryID
			continue
		}
		if !updatedNotification && strings.HasPrefix(f, prefix+"Notification.") {
			updatedNotification = true
			if patcher.Notification == nil {
				patchee.Notification = nil
				continue
			}
			if patchee.Notification == nil {
				patchee.Notification = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notification, patcher.Notification, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notification.", db); err != nil {
				return nil, err
			} else {
				patchee.Notification = o
			}
			continue
		}
		if f == prefix+"Notification" {
			updatedNotification = true
			patchee.Notification = patcher.Notification
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationSMS executes a gorm list call
func DefaultListNotificationSMS(ctx context.Context, db *gorm.DB) ([]*NotificationSMS, error) {
	in := NotificationSMS{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationSMSORM{}, &NotificationSMS{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("sms_delivery_id")
	ormResponse := []NotificationSMSORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationSMS{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationSMSORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationSMSORM) error
}

// DefaultCreateNotificationEmail executes a basic gorm create call
func DefaultCreateNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationEmailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.EmailDeliveryID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationEmailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationEmailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationEmailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationEmailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.EmailDeliveryID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationEmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationEmailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationEmailSet(ctx context.Context, in []*NotificationEmail, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.EmailDeliveryID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.EmailDeliveryID)
	}
	if hook, ok := (interface{}(&NotificationEmailORM{})).(NotificationEmailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("email_delivery_id in (?)", keys).Delete(&NotificationEmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationEmailORM{})).(NotificationEmailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationEmailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationEmail, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationEmail, *gorm.DB) error
}

// DefaultStrictUpdateNotificationEmail clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationEmailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("email_delivery_id=?", ormObj.EmailDeliveryID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationEmailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationEmail executes a basic gorm update call with patch behavior
func DefaultPatchNotificationEmail(ctx context.Context, in *NotificationEmail, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationEmail
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationEmailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationEmailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationEmail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationEmailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationEmail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationEmailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationEmailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationEmail executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationEmail(ctx context.Context, objects []*NotificationEmail, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationEmail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationEmail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationEmail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationEmail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationEmail(ctx context.Context, patchee *NotificationEmail, patcher *NotificationEmail, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationEmail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotification bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"EmailDeliveryID" {
			patchee.EmailDeliveryID = patcher.EmailDeliveryID
			continue
		}
		if !updatedNotification && strings.HasPrefix(f, prefix+"Notification.") {
			updatedNotification = true
			if patcher.Notification == nil {
				patchee.Notification = nil
				continue
			}
			if patchee.Notification == nil {
				patchee.Notification = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notification, patcher.Notification, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notification.", db); err != nil {
				return nil, err
			} else {
				patchee.Notification = o
			}
			continue
		}
		if f == prefix+"Notification" {
			updatedNotification = true
			patchee.Notification = patcher.Notification
			continue
		}
		if f == prefix+"Subject" {
			patchee.Subject = patcher.Subject
			continue
		}
		if f == prefix+"Body" {
			patchee.Body = patcher.Body
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationEmail executes a gorm list call
func DefaultListNotificationEmail(ctx context.Context, db *gorm.DB) ([]*NotificationEmail, error) {
	in := NotificationEmail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationEmailORM{}, &NotificationEmail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("email_delivery_id")
	ormResponse := []NotificationEmailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationEmail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationEmailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationEmailORM) error
}
