package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type PayrollTransferTransactionORM struct {
	CreatedAt            *time.Time `gorm:"not null"`
	Data                 string     `gorm:"type:jsonb"`
	Id                   uint64     `gorm:"primary_key;not null"`
	TaskID               uint64
	TransactionID        string
	TransactionServiceID uint64
	UpdatedAt            *time.Time `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (PayrollTransferTransactionORM) TableName() string {
	return "payroll_transfer_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PayrollTransferTransaction) ToORM(ctx context.Context) (PayrollTransferTransactionORM, error) {
	to := PayrollTransferTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PayrollTransferTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.TransactionServiceID = m.TransactionServiceID
	to.Data = m.Data
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(PayrollTransferTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PayrollTransferTransactionORM) ToPB(ctx context.Context) (PayrollTransferTransaction, error) {
	to := PayrollTransferTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PayrollTransferTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.TransactionServiceID = m.TransactionServiceID
	to.Data = m.Data
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(PayrollTransferTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PayrollTransferTransaction the arg will be the target, the caller the one being converted from

// PayrollTransferTransactionBeforeToORM called before default ToORM code
type PayrollTransferTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PayrollTransferTransactionORM) error
}

// PayrollTransferTransactionAfterToORM called after default ToORM code
type PayrollTransferTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PayrollTransferTransactionORM) error
}

// PayrollTransferTransactionBeforeToPB called before default ToPB code
type PayrollTransferTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PayrollTransferTransaction) error
}

// PayrollTransferTransactionAfterToPB called after default ToPB code
type PayrollTransferTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PayrollTransferTransaction) error
}

type MassTransferListORM struct {
	BeneficiaryAccount string
	CreatedAt          *time.Time `gorm:"not null"`
	Data               string     `gorm:"type:jsonb"`
	Id                 uint64     `gorm:"primary_key;not null"`
	InquiryResult      string     `gorm:"type:jsonb"`
	InquiryValid       bool
	TaskID             uint64
	TransferResult     string `gorm:"type:jsonb"`
	TransferValid      bool
	Type               int32
	UpdatedAt          *time.Time `gorm:"not null"`
	UserID             uint64
	Validation         string `gorm:"type:jsonb"`
	ValidationValid    bool
}

// TableName overrides the default tablename generated by GORM
func (MassTransferListORM) TableName() string {
	return "mass_transfer_list"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MassTransferList) ToORM(ctx context.Context) (MassTransferListORM, error) {
	to := MassTransferListORM{}
	var err error
	if prehook, ok := interface{}(m).(MassTransferListWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	to.Validation = m.Validation
	to.InquiryResult = m.InquiryResult
	to.TransferResult = m.TransferResult
	to.Type = int32(m.Type)
	to.ValidationValid = m.ValidationValid
	to.InquiryValid = m.InquiryValid
	to.TransferValid = m.TransferValid
	to.BeneficiaryAccount = m.BeneficiaryAccount
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MassTransferListWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MassTransferListORM) ToPB(ctx context.Context) (MassTransferList, error) {
	to := MassTransferList{}
	var err error
	if prehook, ok := interface{}(m).(MassTransferListWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	to.Validation = m.Validation
	to.InquiryResult = m.InquiryResult
	to.TransferResult = m.TransferResult
	to.Type = MassTransactionType(m.Type)
	to.ValidationValid = m.ValidationValid
	to.InquiryValid = m.InquiryValid
	to.TransferValid = m.TransferValid
	to.BeneficiaryAccount = m.BeneficiaryAccount
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(MassTransferListWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MassTransferList the arg will be the target, the caller the one being converted from

// MassTransferListBeforeToORM called before default ToORM code
type MassTransferListWithBeforeToORM interface {
	BeforeToORM(context.Context, *MassTransferListORM) error
}

// MassTransferListAfterToORM called after default ToORM code
type MassTransferListWithAfterToORM interface {
	AfterToORM(context.Context, *MassTransferListORM) error
}

// MassTransferListBeforeToPB called before default ToPB code
type MassTransferListWithBeforeToPB interface {
	BeforeToPB(context.Context, *MassTransferList) error
}

// MassTransferListAfterToPB called after default ToPB code
type MassTransferListWithAfterToPB interface {
	AfterToPB(context.Context, *MassTransferList) error
}

type MassInquiryJobORM struct {
	Comment   string
	CreatedAt *time.Time `gorm:"not null"`
	Data      string     `gorm:"type:jsonb"`
	Id        uint64     `gorm:"primary_key;not null"`
	InQueue   string
	Retry     uint64
	RunAt     *time.Time
	TaskID    uint64
	UpdatedAt *time.Time `gorm:"not null"`
	UserID    uint64
}

// TableName overrides the default tablename generated by GORM
func (MassInquiryJobORM) TableName() string {
	return "check_mass_inquiry_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MassInquiryJob) ToORM(ctx context.Context) (MassInquiryJobORM, error) {
	to := MassInquiryJobORM{}
	var err error
	if prehook, ok := interface{}(m).(MassInquiryJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MassInquiryJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MassInquiryJobORM) ToPB(ctx context.Context) (MassInquiryJob, error) {
	to := MassInquiryJob{}
	var err error
	if prehook, ok := interface{}(m).(MassInquiryJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(MassInquiryJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MassInquiryJob the arg will be the target, the caller the one being converted from

// MassInquiryJobBeforeToORM called before default ToORM code
type MassInquiryJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *MassInquiryJobORM) error
}

// MassInquiryJobAfterToORM called after default ToORM code
type MassInquiryJobWithAfterToORM interface {
	AfterToORM(context.Context, *MassInquiryJobORM) error
}

// MassInquiryJobBeforeToPB called before default ToPB code
type MassInquiryJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *MassInquiryJob) error
}

// MassInquiryJobAfterToPB called after default ToPB code
type MassInquiryJobWithAfterToPB interface {
	AfterToPB(context.Context, *MassInquiryJob) error
}

type MassTransferJobORM struct {
	Comment   string
	CompanyID uint64
	CreatedAt *time.Time `gorm:"not null"`
	Data      string     `gorm:"type:jsonb"`
	Id        uint64     `gorm:"primary_key;not null"`
	InQueue   string
	Retry     uint64
	RunAt     *time.Time
	TaskID    uint64
	UpdatedAt *time.Time `gorm:"not null"`
	UserID    uint64
}

// TableName overrides the default tablename generated by GORM
func (MassTransferJobORM) TableName() string {
	return "check_mass_transfer_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MassTransferJob) ToORM(ctx context.Context) (MassTransferJobORM, error) {
	to := MassTransferJobORM{}
	var err error
	if prehook, ok := interface{}(m).(MassTransferJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MassTransferJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MassTransferJobORM) ToPB(ctx context.Context) (MassTransferJob, error) {
	to := MassTransferJob{}
	var err error
	if prehook, ok := interface{}(m).(MassTransferJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(MassTransferJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MassTransferJob the arg will be the target, the caller the one being converted from

// MassTransferJobBeforeToORM called before default ToORM code
type MassTransferJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *MassTransferJobORM) error
}

// MassTransferJobAfterToORM called after default ToORM code
type MassTransferJobWithAfterToORM interface {
	AfterToORM(context.Context, *MassTransferJobORM) error
}

// MassTransferJobBeforeToPB called before default ToPB code
type MassTransferJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *MassTransferJob) error
}

// MassTransferJobAfterToPB called after default ToPB code
type MassTransferJobWithAfterToPB interface {
	AfterToPB(context.Context, *MassTransferJob) error
}

type CreateMassTransferJobORM struct {
	Comment   string
	CreatedAt *time.Time `gorm:"not null"`
	Id        uint64     `gorm:"primary_key;not null"`
	InQueue   string
	Retry     uint64
	RunAt     *time.Time
	Success   bool
	TaskID    uint64
	UpdatedAt *time.Time `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (CreateMassTransferJobORM) TableName() string {
	return "create_mass_transfer_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreateMassTransferJob) ToORM(ctx context.Context) (CreateMassTransferJobORM, error) {
	to := CreateMassTransferJobORM{}
	var err error
	if prehook, ok := interface{}(m).(CreateMassTransferJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.Success = m.Success
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(CreateMassTransferJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreateMassTransferJobORM) ToPB(ctx context.Context) (CreateMassTransferJob, error) {
	to := CreateMassTransferJob{}
	var err error
	if prehook, ok := interface{}(m).(CreateMassTransferJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.Success = m.Success
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(CreateMassTransferJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreateMassTransferJob the arg will be the target, the caller the one being converted from

// CreateMassTransferJobBeforeToORM called before default ToORM code
type CreateMassTransferJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreateMassTransferJobORM) error
}

// CreateMassTransferJobAfterToORM called after default ToORM code
type CreateMassTransferJobWithAfterToORM interface {
	AfterToORM(context.Context, *CreateMassTransferJobORM) error
}

// CreateMassTransferJobBeforeToPB called before default ToPB code
type CreateMassTransferJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreateMassTransferJob) error
}

// CreateMassTransferJobAfterToPB called after default ToPB code
type CreateMassTransferJobWithAfterToPB interface {
	AfterToPB(context.Context, *CreateMassTransferJob) error
}

type CheckPayrollTransferFileJobORM struct {
	Comment       string
	CompanyID     uint64
	CreatedAt     *time.Time `gorm:"not null"`
	CreatedByID   uint64
	Data          string `gorm:"type:jsonb"`
	FileName      string
	Id            uint64 `gorm:"primary_key;not null"`
	InQueue       string
	Retry         uint64
	RunAt         *time.Time
	Success       bool
	TaskID        uint64
	TransactionID string
	UpdatedAt     *time.Time `gorm:"not null"`
	UpdatedByID   uint64
}

// TableName overrides the default tablename generated by GORM
func (CheckPayrollTransferFileJobORM) TableName() string {
	return "check_payroll_transfer_file_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CheckPayrollTransferFileJob) ToORM(ctx context.Context) (CheckPayrollTransferFileJobORM, error) {
	to := CheckPayrollTransferFileJobORM{}
	var err error
	if prehook, ok := interface{}(m).(CheckPayrollTransferFileJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	to.FileName = m.FileName
	to.Success = m.Success
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Retry = m.Retry
	to.Comment = m.Comment
	to.InQueue = m.InQueue
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(CheckPayrollTransferFileJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CheckPayrollTransferFileJobORM) ToPB(ctx context.Context) (CheckPayrollTransferFileJob, error) {
	to := CheckPayrollTransferFileJob{}
	var err error
	if prehook, ok := interface{}(m).(CheckPayrollTransferFileJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	to.FileName = m.FileName
	to.Success = m.Success
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Retry = m.Retry
	to.Comment = m.Comment
	to.InQueue = m.InQueue
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(CheckPayrollTransferFileJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CheckPayrollTransferFileJob the arg will be the target, the caller the one being converted from

// CheckPayrollTransferFileJobBeforeToORM called before default ToORM code
type CheckPayrollTransferFileJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *CheckPayrollTransferFileJobORM) error
}

// CheckPayrollTransferFileJobAfterToORM called after default ToORM code
type CheckPayrollTransferFileJobWithAfterToORM interface {
	AfterToORM(context.Context, *CheckPayrollTransferFileJobORM) error
}

// CheckPayrollTransferFileJobBeforeToPB called before default ToPB code
type CheckPayrollTransferFileJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *CheckPayrollTransferFileJob) error
}

// CheckPayrollTransferFileJobAfterToPB called after default ToPB code
type CheckPayrollTransferFileJobWithAfterToPB interface {
	AfterToPB(context.Context, *CheckPayrollTransferFileJob) error
}

type UploadedFileNameORM struct {
	CompanyID        uint64
	CreatedAt        *time.Time `gorm:"not null"`
	Finished         bool
	Id               uint64 `gorm:"primary_key;not null"`
	OriginalFileName string
	UpdatedAt        *time.Time `gorm:"not null"`
	UploadedFileName string     `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (UploadedFileNameORM) TableName() string {
	return "uploaded_file_names"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UploadedFileName) ToORM(ctx context.Context) (UploadedFileNameORM, error) {
	to := UploadedFileNameORM{}
	var err error
	if prehook, ok := interface{}(m).(UploadedFileNameWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UploadedFileName = m.UploadedFileName
	to.OriginalFileName = m.OriginalFileName
	to.CompanyID = m.CompanyID
	to.Finished = m.Finished
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(UploadedFileNameWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UploadedFileNameORM) ToPB(ctx context.Context) (UploadedFileName, error) {
	to := UploadedFileName{}
	var err error
	if prehook, ok := interface{}(m).(UploadedFileNameWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UploadedFileName = m.UploadedFileName
	to.OriginalFileName = m.OriginalFileName
	to.CompanyID = m.CompanyID
	to.Finished = m.Finished
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(UploadedFileNameWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UploadedFileName the arg will be the target, the caller the one being converted from

// UploadedFileNameBeforeToORM called before default ToORM code
type UploadedFileNameWithBeforeToORM interface {
	BeforeToORM(context.Context, *UploadedFileNameORM) error
}

// UploadedFileNameAfterToORM called after default ToORM code
type UploadedFileNameWithAfterToORM interface {
	AfterToORM(context.Context, *UploadedFileNameORM) error
}

// UploadedFileNameBeforeToPB called before default ToPB code
type UploadedFileNameWithBeforeToPB interface {
	BeforeToPB(context.Context, *UploadedFileName) error
}

// UploadedFileNameAfterToPB called after default ToPB code
type UploadedFileNameWithAfterToPB interface {
	AfterToPB(context.Context, *UploadedFileName) error
}

// DefaultCreatePayrollTransferTransaction executes a basic gorm create call
func DefaultCreatePayrollTransferTransaction(ctx context.Context, in *PayrollTransferTransaction, db *gorm.DB) (*PayrollTransferTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PayrollTransferTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPayrollTransferTransaction(ctx context.Context, in *PayrollTransferTransaction, db *gorm.DB) (*PayrollTransferTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PayrollTransferTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PayrollTransferTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PayrollTransferTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PayrollTransferTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePayrollTransferTransaction(ctx context.Context, in *PayrollTransferTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PayrollTransferTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PayrollTransferTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePayrollTransferTransactionSet(ctx context.Context, in []*PayrollTransferTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PayrollTransferTransactionORM{})).(PayrollTransferTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PayrollTransferTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PayrollTransferTransactionORM{})).(PayrollTransferTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PayrollTransferTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PayrollTransferTransaction, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PayrollTransferTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePayrollTransferTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePayrollTransferTransaction(ctx context.Context, in *PayrollTransferTransaction, db *gorm.DB) (*PayrollTransferTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePayrollTransferTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PayrollTransferTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PayrollTransferTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPayrollTransferTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPayrollTransferTransaction(ctx context.Context, in *PayrollTransferTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PayrollTransferTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PayrollTransferTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PayrollTransferTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPayrollTransferTransaction(ctx, &PayrollTransferTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PayrollTransferTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPayrollTransferTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PayrollTransferTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePayrollTransferTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PayrollTransferTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PayrollTransferTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PayrollTransferTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PayrollTransferTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PayrollTransferTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PayrollTransferTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPayrollTransferTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPayrollTransferTransaction(ctx context.Context, objects []*PayrollTransferTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PayrollTransferTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PayrollTransferTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPayrollTransferTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPayrollTransferTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPayrollTransferTransaction(ctx context.Context, patchee *PayrollTransferTransaction, patcher *PayrollTransferTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PayrollTransferTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"TransactionID" {
			patchee.TransactionID = patcher.TransactionID
			continue
		}
		if f == prefix+"TransactionServiceID" {
			patchee.TransactionServiceID = patcher.TransactionServiceID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPayrollTransferTransaction executes a gorm list call
func DefaultListPayrollTransferTransaction(ctx context.Context, db *gorm.DB) ([]*PayrollTransferTransaction, error) {
	in := PayrollTransferTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PayrollTransferTransactionORM{}, &PayrollTransferTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PayrollTransferTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PayrollTransferTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PayrollTransferTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PayrollTransferTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PayrollTransferTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PayrollTransferTransactionORM) error
}

// DefaultCreateMassTransferList executes a basic gorm create call
func DefaultCreateMassTransferList(ctx context.Context, in *MassTransferList, db *gorm.DB) (*MassTransferList, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MassTransferListORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMassTransferList(ctx context.Context, in *MassTransferList, db *gorm.DB) (*MassTransferList, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MassTransferListORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MassTransferListORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MassTransferListORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MassTransferListORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMassTransferList(ctx context.Context, in *MassTransferList, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MassTransferListORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MassTransferListORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMassTransferListSet(ctx context.Context, in []*MassTransferList, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MassTransferListORM{})).(MassTransferListORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MassTransferListORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MassTransferListORM{})).(MassTransferListORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MassTransferListORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MassTransferList, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MassTransferList, *gorm.DB) error
}

// DefaultStrictUpdateMassTransferList clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMassTransferList(ctx context.Context, in *MassTransferList, db *gorm.DB) (*MassTransferList, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMassTransferList")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MassTransferListORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MassTransferListORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMassTransferList executes a basic gorm update call with patch behavior
func DefaultPatchMassTransferList(ctx context.Context, in *MassTransferList, updateMask *field_mask.FieldMask, db *gorm.DB) (*MassTransferList, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MassTransferList
	var err error
	if hook, ok := interface{}(&pbObj).(MassTransferListWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMassTransferList(ctx, &MassTransferList{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MassTransferListWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMassTransferList(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MassTransferListWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMassTransferList(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MassTransferListWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MassTransferListWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MassTransferList, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MassTransferList, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MassTransferList, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MassTransferList, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMassTransferList executes a bulk gorm update call with patch behavior
func DefaultPatchSetMassTransferList(ctx context.Context, objects []*MassTransferList, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MassTransferList, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MassTransferList, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMassTransferList(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMassTransferList patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMassTransferList(ctx context.Context, patchee *MassTransferList, patcher *MassTransferList, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MassTransferList, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if f == prefix+"Validation" {
			patchee.Validation = patcher.Validation
			continue
		}
		if f == prefix+"InquiryResult" {
			patchee.InquiryResult = patcher.InquiryResult
			continue
		}
		if f == prefix+"TransferResult" {
			patchee.TransferResult = patcher.TransferResult
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"ValidationValid" {
			patchee.ValidationValid = patcher.ValidationValid
			continue
		}
		if f == prefix+"InquiryValid" {
			patchee.InquiryValid = patcher.InquiryValid
			continue
		}
		if f == prefix+"TransferValid" {
			patchee.TransferValid = patcher.TransferValid
			continue
		}
		if f == prefix+"BeneficiaryAccount" {
			patchee.BeneficiaryAccount = patcher.BeneficiaryAccount
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMassTransferList executes a gorm list call
func DefaultListMassTransferList(ctx context.Context, db *gorm.DB) ([]*MassTransferList, error) {
	in := MassTransferList{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MassTransferListORM{}, &MassTransferList{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MassTransferListORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferListORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MassTransferList{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MassTransferListORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferListORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MassTransferListORM) error
}

// DefaultCreateMassInquiryJob executes a basic gorm create call
func DefaultCreateMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MassInquiryJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MassInquiryJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MassInquiryJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MassInquiryJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MassInquiryJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MassInquiryJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MassInquiryJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMassInquiryJobSet(ctx context.Context, in []*MassInquiryJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MassInquiryJobORM{})).(MassInquiryJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MassInquiryJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MassInquiryJobORM{})).(MassInquiryJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MassInquiryJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MassInquiryJob, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MassInquiryJob, *gorm.DB) error
}

// DefaultStrictUpdateMassInquiryJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMassInquiryJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MassInquiryJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MassInquiryJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMassInquiryJob executes a basic gorm update call with patch behavior
func DefaultPatchMassInquiryJob(ctx context.Context, in *MassInquiryJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MassInquiryJob
	var err error
	if hook, ok := interface{}(&pbObj).(MassInquiryJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMassInquiryJob(ctx, &MassInquiryJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MassInquiryJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMassInquiryJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MassInquiryJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMassInquiryJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MassInquiryJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MassInquiryJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMassInquiryJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetMassInquiryJob(ctx context.Context, objects []*MassInquiryJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MassInquiryJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MassInquiryJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMassInquiryJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMassInquiryJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMassInquiryJob(ctx context.Context, patchee *MassInquiryJob, patcher *MassInquiryJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MassInquiryJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMassInquiryJob executes a gorm list call
func DefaultListMassInquiryJob(ctx context.Context, db *gorm.DB) ([]*MassInquiryJob, error) {
	in := MassInquiryJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MassInquiryJobORM{}, &MassInquiryJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MassInquiryJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MassInquiryJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MassInquiryJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MassInquiryJobORM) error
}

// DefaultCreateMassTransferJob executes a basic gorm create call
func DefaultCreateMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MassTransferJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MassTransferJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MassTransferJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MassTransferJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MassTransferJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MassTransferJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMassTransferJobSet(ctx context.Context, in []*MassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MassTransferJobORM{})).(MassTransferJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MassTransferJobORM{})).(MassTransferJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MassTransferJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MassTransferJob, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MassTransferJob, *gorm.DB) error
}

// DefaultStrictUpdateMassTransferJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMassTransferJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MassTransferJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MassTransferJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMassTransferJob executes a basic gorm update call with patch behavior
func DefaultPatchMassTransferJob(ctx context.Context, in *MassTransferJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MassTransferJob
	var err error
	if hook, ok := interface{}(&pbObj).(MassTransferJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMassTransferJob(ctx, &MassTransferJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MassTransferJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMassTransferJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MassTransferJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMassTransferJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MassTransferJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MassTransferJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMassTransferJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetMassTransferJob(ctx context.Context, objects []*MassTransferJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MassTransferJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MassTransferJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMassTransferJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMassTransferJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMassTransferJob(ctx context.Context, patchee *MassTransferJob, patcher *MassTransferJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MassTransferJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMassTransferJob executes a gorm list call
func DefaultListMassTransferJob(ctx context.Context, db *gorm.DB) ([]*MassTransferJob, error) {
	in := MassTransferJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MassTransferJobORM{}, &MassTransferJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MassTransferJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MassTransferJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MassTransferJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MassTransferJobORM) error
}

// DefaultCreateCreateMassTransferJob executes a basic gorm create call
func DefaultCreateCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreateMassTransferJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreateMassTransferJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreateMassTransferJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreateMassTransferJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreateMassTransferJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreateMassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreateMassTransferJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreateMassTransferJobSet(ctx context.Context, in []*CreateMassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreateMassTransferJobORM{})).(CreateMassTransferJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreateMassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreateMassTransferJobORM{})).(CreateMassTransferJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreateMassTransferJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreateMassTransferJob, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreateMassTransferJob, *gorm.DB) error
}

// DefaultStrictUpdateCreateMassTransferJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreateMassTransferJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreateMassTransferJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreateMassTransferJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreateMassTransferJob executes a basic gorm update call with patch behavior
func DefaultPatchCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreateMassTransferJob
	var err error
	if hook, ok := interface{}(&pbObj).(CreateMassTransferJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreateMassTransferJob(ctx, &CreateMassTransferJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreateMassTransferJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreateMassTransferJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreateMassTransferJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreateMassTransferJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreateMassTransferJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreateMassTransferJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreateMassTransferJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreateMassTransferJob(ctx context.Context, objects []*CreateMassTransferJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreateMassTransferJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreateMassTransferJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreateMassTransferJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreateMassTransferJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreateMassTransferJob(ctx context.Context, patchee *CreateMassTransferJob, patcher *CreateMassTransferJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreateMassTransferJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"Success" {
			patchee.Success = patcher.Success
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreateMassTransferJob executes a gorm list call
func DefaultListCreateMassTransferJob(ctx context.Context, db *gorm.DB) ([]*CreateMassTransferJob, error) {
	in := CreateMassTransferJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreateMassTransferJobORM{}, &CreateMassTransferJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreateMassTransferJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreateMassTransferJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreateMassTransferJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreateMassTransferJobORM) error
}

// DefaultCreateCheckPayrollTransferFileJob executes a basic gorm create call
func DefaultCreateCheckPayrollTransferFileJob(ctx context.Context, in *CheckPayrollTransferFileJob, db *gorm.DB) (*CheckPayrollTransferFileJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CheckPayrollTransferFileJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCheckPayrollTransferFileJob(ctx context.Context, in *CheckPayrollTransferFileJob, db *gorm.DB) (*CheckPayrollTransferFileJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CheckPayrollTransferFileJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CheckPayrollTransferFileJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CheckPayrollTransferFileJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CheckPayrollTransferFileJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCheckPayrollTransferFileJob(ctx context.Context, in *CheckPayrollTransferFileJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CheckPayrollTransferFileJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CheckPayrollTransferFileJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCheckPayrollTransferFileJobSet(ctx context.Context, in []*CheckPayrollTransferFileJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CheckPayrollTransferFileJobORM{})).(CheckPayrollTransferFileJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CheckPayrollTransferFileJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CheckPayrollTransferFileJobORM{})).(CheckPayrollTransferFileJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CheckPayrollTransferFileJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CheckPayrollTransferFileJob, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CheckPayrollTransferFileJob, *gorm.DB) error
}

// DefaultStrictUpdateCheckPayrollTransferFileJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCheckPayrollTransferFileJob(ctx context.Context, in *CheckPayrollTransferFileJob, db *gorm.DB) (*CheckPayrollTransferFileJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCheckPayrollTransferFileJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CheckPayrollTransferFileJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CheckPayrollTransferFileJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCheckPayrollTransferFileJob executes a basic gorm update call with patch behavior
func DefaultPatchCheckPayrollTransferFileJob(ctx context.Context, in *CheckPayrollTransferFileJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*CheckPayrollTransferFileJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CheckPayrollTransferFileJob
	var err error
	if hook, ok := interface{}(&pbObj).(CheckPayrollTransferFileJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCheckPayrollTransferFileJob(ctx, &CheckPayrollTransferFileJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CheckPayrollTransferFileJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCheckPayrollTransferFileJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CheckPayrollTransferFileJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCheckPayrollTransferFileJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CheckPayrollTransferFileJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CheckPayrollTransferFileJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CheckPayrollTransferFileJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CheckPayrollTransferFileJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CheckPayrollTransferFileJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CheckPayrollTransferFileJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCheckPayrollTransferFileJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetCheckPayrollTransferFileJob(ctx context.Context, objects []*CheckPayrollTransferFileJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CheckPayrollTransferFileJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CheckPayrollTransferFileJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCheckPayrollTransferFileJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCheckPayrollTransferFileJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCheckPayrollTransferFileJob(ctx context.Context, patchee *CheckPayrollTransferFileJob, patcher *CheckPayrollTransferFileJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CheckPayrollTransferFileJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"TransactionID" {
			patchee.TransactionID = patcher.TransactionID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"Success" {
			patchee.Success = patcher.Success
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCheckPayrollTransferFileJob executes a gorm list call
func DefaultListCheckPayrollTransferFileJob(ctx context.Context, db *gorm.DB) ([]*CheckPayrollTransferFileJob, error) {
	in := CheckPayrollTransferFileJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CheckPayrollTransferFileJobORM{}, &CheckPayrollTransferFileJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CheckPayrollTransferFileJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CheckPayrollTransferFileJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CheckPayrollTransferFileJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CheckPayrollTransferFileJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CheckPayrollTransferFileJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CheckPayrollTransferFileJobORM) error
}

// DefaultCreateUploadedFileName executes a basic gorm create call
func DefaultCreateUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UploadedFileNameORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UploadedFileNameORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UploadedFileNameORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UploadedFileNameORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UploadedFileNameORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UploadedFileNameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UploadedFileNameORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUploadedFileNameSet(ctx context.Context, in []*UploadedFileName, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UploadedFileNameORM{})).(UploadedFileNameORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UploadedFileNameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UploadedFileNameORM{})).(UploadedFileNameORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UploadedFileNameORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UploadedFileName, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UploadedFileName, *gorm.DB) error
}

// DefaultStrictUpdateUploadedFileName clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUploadedFileName")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UploadedFileNameORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UploadedFileNameORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUploadedFileName executes a basic gorm update call with patch behavior
func DefaultPatchUploadedFileName(ctx context.Context, in *UploadedFileName, updateMask *field_mask.FieldMask, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UploadedFileName
	var err error
	if hook, ok := interface{}(&pbObj).(UploadedFileNameWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUploadedFileName(ctx, &UploadedFileName{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UploadedFileNameWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUploadedFileName(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UploadedFileNameWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUploadedFileName(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UploadedFileNameWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UploadedFileNameWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUploadedFileName executes a bulk gorm update call with patch behavior
func DefaultPatchSetUploadedFileName(ctx context.Context, objects []*UploadedFileName, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UploadedFileName, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UploadedFileName, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUploadedFileName(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUploadedFileName patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUploadedFileName(ctx context.Context, patchee *UploadedFileName, patcher *UploadedFileName, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UploadedFileName, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UploadedFileName" {
			patchee.UploadedFileName = patcher.UploadedFileName
			continue
		}
		if f == prefix+"OriginalFileName" {
			patchee.OriginalFileName = patcher.OriginalFileName
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Finished" {
			patchee.Finished = patcher.Finished
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUploadedFileName executes a gorm list call
func DefaultListUploadedFileName(ctx context.Context, db *gorm.DB) ([]*UploadedFileName, error) {
	in := UploadedFileName{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UploadedFileNameORM{}, &UploadedFileName{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UploadedFileNameORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UploadedFileName{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UploadedFileNameORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UploadedFileNameORM) error
}
