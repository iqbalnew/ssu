package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserORM struct {
	CreatedAt *time.Time
	DeletedAt *time.Time
	Id        uint64 `gorm:"primary_key;not null"`
	Password  string `gorm:"not null"`
	Role      string `gorm:"default:user;not null"`
	UpdatedAt *time.Time
	Username  string `gorm:"unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type CompanyGroupORM struct {
	CompanyLimits      []*CompanyLimitORM `gorm:"foreignkey:group_id;association_foreignkey:GroupID;preload:true"`
	CreatedAt          *time.Time
	CreatedByID        uint64
	DeletedAt          *time.Time
	DeletedByID        uint64
	GroupID            uint64                `gorm:"primary_key;not null"`
	GroupLimits        []*GroupLimitORM      `gorm:"foreignkey:group_id;association_foreignkey:GroupID;preload:true"`
	GroupSubsidiaries  []*GroupSubsidiaryORM `gorm:"foreignkey:group_id;association_foreignkey:GroupID;preload:true"`
	HoldingCompanyID   uint64
	HoldingCompanyName string
	Name               string `gorm:"type:varchar(255)"`
	UpdatedAt          *time.Time
	UpdatedByID        uint64
}

// TableName overrides the default tablename generated by GORM
func (CompanyGroupORM) TableName() string {
	return "company_groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyGroup) ToORM(ctx context.Context) (CompanyGroupORM, error) {
	to := CompanyGroupORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyGroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	to.Name = m.Name
	to.HoldingCompanyID = m.HoldingCompanyID
	to.HoldingCompanyName = m.HoldingCompanyName
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.GroupLimits {
		if v != nil {
			if tempGroupLimits, cErr := v.ToORM(ctx); cErr == nil {
				to.GroupLimits = append(to.GroupLimits, &tempGroupLimits)
			} else {
				return to, cErr
			}
		} else {
			to.GroupLimits = append(to.GroupLimits, nil)
		}
	}
	for _, v := range m.CompanyLimits {
		if v != nil {
			if tempCompanyLimits, cErr := v.ToORM(ctx); cErr == nil {
				to.CompanyLimits = append(to.CompanyLimits, &tempCompanyLimits)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyLimits = append(to.CompanyLimits, nil)
		}
	}
	for _, v := range m.GroupSubsidiaries {
		if v != nil {
			if tempGroupSubsidiaries, cErr := v.ToORM(ctx); cErr == nil {
				to.GroupSubsidiaries = append(to.GroupSubsidiaries, &tempGroupSubsidiaries)
			} else {
				return to, cErr
			}
		} else {
			to.GroupSubsidiaries = append(to.GroupSubsidiaries, nil)
		}
	}
	if posthook, ok := interface{}(m).(CompanyGroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyGroupORM) ToPB(ctx context.Context) (CompanyGroup, error) {
	to := CompanyGroup{}
	var err error
	if prehook, ok := interface{}(m).(CompanyGroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	to.Name = m.Name
	to.HoldingCompanyID = m.HoldingCompanyID
	to.HoldingCompanyName = m.HoldingCompanyName
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.GroupLimits {
		if v != nil {
			if tempGroupLimits, cErr := v.ToPB(ctx); cErr == nil {
				to.GroupLimits = append(to.GroupLimits, &tempGroupLimits)
			} else {
				return to, cErr
			}
		} else {
			to.GroupLimits = append(to.GroupLimits, nil)
		}
	}
	for _, v := range m.CompanyLimits {
		if v != nil {
			if tempCompanyLimits, cErr := v.ToPB(ctx); cErr == nil {
				to.CompanyLimits = append(to.CompanyLimits, &tempCompanyLimits)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyLimits = append(to.CompanyLimits, nil)
		}
	}
	for _, v := range m.GroupSubsidiaries {
		if v != nil {
			if tempGroupSubsidiaries, cErr := v.ToPB(ctx); cErr == nil {
				to.GroupSubsidiaries = append(to.GroupSubsidiaries, &tempGroupSubsidiaries)
			} else {
				return to, cErr
			}
		} else {
			to.GroupSubsidiaries = append(to.GroupSubsidiaries, nil)
		}
	}
	if posthook, ok := interface{}(m).(CompanyGroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyGroup the arg will be the target, the caller the one being converted from

// CompanyGroupBeforeToORM called before default ToORM code
type CompanyGroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyGroupORM) error
}

// CompanyGroupAfterToORM called after default ToORM code
type CompanyGroupWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyGroupORM) error
}

// CompanyGroupBeforeToPB called before default ToPB code
type CompanyGroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyGroup) error
}

// CompanyGroupAfterToPB called after default ToPB code
type CompanyGroupWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyGroup) error
}

type GroupLimitORM struct {
	CreatedAt   *time.Time
	CreatedByID uint64
	Currency    *CurrencyORM `gorm:"foreignkey:CurrencyId;association_foreignkey:CurrencyID"`
	CurrencyID  uint64
	CurrencyId  *uint64
	DeletedAt   *time.Time
	DeletedByID uint64
	GroupID     uint64 `gorm:"primary_key;not null"`
	Limit       uint64
	UpdatedAt   *time.Time
	UpdatedByID uint64
	group_id    *uint64
}

// TableName overrides the default tablename generated by GORM
func (GroupLimitORM) TableName() string {
	return "group_limits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *GroupLimit) ToORM(ctx context.Context) (GroupLimitORM, error) {
	to := GroupLimitORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupLimitWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	to.CurrencyID = m.CurrencyID
	if posthook, ok := interface{}(m).(GroupLimitWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupLimitORM) ToPB(ctx context.Context) (GroupLimit, error) {
	to := GroupLimit{}
	var err error
	if prehook, ok := interface{}(m).(GroupLimitWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	to.CurrencyID = m.CurrencyID
	if posthook, ok := interface{}(m).(GroupLimitWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type GroupLimit the arg will be the target, the caller the one being converted from

// GroupLimitBeforeToORM called before default ToORM code
type GroupLimitWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupLimitORM) error
}

// GroupLimitAfterToORM called after default ToORM code
type GroupLimitWithAfterToORM interface {
	AfterToORM(context.Context, *GroupLimitORM) error
}

// GroupLimitBeforeToPB called before default ToPB code
type GroupLimitWithBeforeToPB interface {
	BeforeToPB(context.Context, *GroupLimit) error
}

// GroupLimitAfterToPB called after default ToPB code
type GroupLimitWithAfterToPB interface {
	AfterToPB(context.Context, *GroupLimit) error
}

type CompanyLimitORM struct {
	CompanyID   uint64 `gorm:"primary_key;not null"`
	CreatedAt   *time.Time
	CreatedByID uint64
	Currency    *CurrencyORM `gorm:"foreignkey:CurrencyId;association_foreignkey:CurrencyID"`
	CurrencyID  uint64
	CurrencyId  *uint64
	DeletedAt   *time.Time
	DeletedByID uint64
	GroupID     uint64 `gorm:"primary_key;not null"`
	Limit       uint64
	UpdatedAt   *time.Time
	UpdatedByID uint64
	group_id    *uint64
}

// TableName overrides the default tablename generated by GORM
func (CompanyLimitORM) TableName() string {
	return "company_limits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyLimit) ToORM(ctx context.Context) (CompanyLimitORM, error) {
	to := CompanyLimitORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyLimitWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	to.CompanyID = m.CompanyID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	to.CurrencyID = m.CurrencyID
	if posthook, ok := interface{}(m).(CompanyLimitWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyLimitORM) ToPB(ctx context.Context) (CompanyLimit, error) {
	to := CompanyLimit{}
	var err error
	if prehook, ok := interface{}(m).(CompanyLimitWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	to.CompanyID = m.CompanyID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	to.CurrencyID = m.CurrencyID
	if posthook, ok := interface{}(m).(CompanyLimitWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyLimit the arg will be the target, the caller the one being converted from

// CompanyLimitBeforeToORM called before default ToORM code
type CompanyLimitWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyLimitORM) error
}

// CompanyLimitAfterToORM called after default ToORM code
type CompanyLimitWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyLimitORM) error
}

// CompanyLimitBeforeToPB called before default ToPB code
type CompanyLimitWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyLimit) error
}

// CompanyLimitAfterToPB called after default ToPB code
type CompanyLimitWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyLimit) error
}

type GroupSubsidiaryORM struct {
	CreatedAt           *time.Time
	CreatedByID         uint64
	DeletedAt           *time.Time
	DeletedByID         uint64
	GroupID             uint64 `gorm:"primary_key;not null"`
	ParentCompanyID     uint64 `gorm:"primary_key;not null"`
	SubsidiaryCompanyID uint64 `gorm:"primary_key;not null"`
	UpdatedAt           *time.Time
	UpdatedByID         uint64
	group_id            *uint64
}

// TableName overrides the default tablename generated by GORM
func (GroupSubsidiaryORM) TableName() string {
	return "group_subsidiaries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *GroupSubsidiary) ToORM(ctx context.Context) (GroupSubsidiaryORM, error) {
	to := GroupSubsidiaryORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupSubsidiaryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	to.ParentCompanyID = m.ParentCompanyID
	to.SubsidiaryCompanyID = m.SubsidiaryCompanyID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(GroupSubsidiaryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupSubsidiaryORM) ToPB(ctx context.Context) (GroupSubsidiary, error) {
	to := GroupSubsidiary{}
	var err error
	if prehook, ok := interface{}(m).(GroupSubsidiaryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.GroupID = m.GroupID
	to.ParentCompanyID = m.ParentCompanyID
	to.SubsidiaryCompanyID = m.SubsidiaryCompanyID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(GroupSubsidiaryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type GroupSubsidiary the arg will be the target, the caller the one being converted from

// GroupSubsidiaryBeforeToORM called before default ToORM code
type GroupSubsidiaryWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupSubsidiaryORM) error
}

// GroupSubsidiaryAfterToORM called after default ToORM code
type GroupSubsidiaryWithAfterToORM interface {
	AfterToORM(context.Context, *GroupSubsidiaryORM) error
}

// GroupSubsidiaryBeforeToPB called before default ToPB code
type GroupSubsidiaryWithBeforeToPB interface {
	BeforeToPB(context.Context, *GroupSubsidiary) error
}

// GroupSubsidiaryAfterToPB called after default ToPB code
type GroupSubsidiaryWithAfterToPB interface {
	AfterToPB(context.Context, *GroupSubsidiary) error
}

type CompanyWorkflowORM struct {
	CompanyID                uint64 `gorm:"primary_key;not null"`
	CreatedAt                *time.Time
	CreatedByID              uint64
	DeletedAt                *time.Time
	DeletedByID              uint64
	IsNonTransactionChecker  bool
	IsNonTransactionReleaser bool
	IsNonTransactionSTP      bool
	IsNonTransactionSigner   bool
	IsTransactionChecker     bool
	IsTransactionReleaser    bool
	IsTransactionSTP         bool
	IsTransactionSigner      bool
	UpdatedAt                *time.Time
	UpdatedByID              uint64
}

// TableName overrides the default tablename generated by GORM
func (CompanyWorkflowORM) TableName() string {
	return "company_workflows"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyWorkflow) ToORM(ctx context.Context) (CompanyWorkflowORM, error) {
	to := CompanyWorkflowORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWorkflowWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.IsTransactionSTP = m.IsTransactionSTP
	to.IsTransactionChecker = m.IsTransactionChecker
	to.IsTransactionSigner = m.IsTransactionSigner
	to.IsTransactionReleaser = m.IsTransactionReleaser
	to.IsNonTransactionSTP = m.IsNonTransactionSTP
	to.IsNonTransactionChecker = m.IsNonTransactionChecker
	to.IsNonTransactionSigner = m.IsNonTransactionSigner
	to.IsNonTransactionReleaser = m.IsNonTransactionReleaser
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(CompanyWorkflowWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyWorkflowORM) ToPB(ctx context.Context) (CompanyWorkflow, error) {
	to := CompanyWorkflow{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWorkflowWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.IsTransactionSTP = m.IsTransactionSTP
	to.IsTransactionChecker = m.IsTransactionChecker
	to.IsTransactionSigner = m.IsTransactionSigner
	to.IsTransactionReleaser = m.IsTransactionReleaser
	to.IsNonTransactionSTP = m.IsNonTransactionSTP
	to.IsNonTransactionChecker = m.IsNonTransactionChecker
	to.IsNonTransactionSigner = m.IsNonTransactionSigner
	to.IsNonTransactionReleaser = m.IsNonTransactionReleaser
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(CompanyWorkflowWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyWorkflow the arg will be the target, the caller the one being converted from

// CompanyWorkflowBeforeToORM called before default ToORM code
type CompanyWorkflowWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyWorkflowORM) error
}

// CompanyWorkflowAfterToORM called after default ToORM code
type CompanyWorkflowWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyWorkflowORM) error
}

// CompanyWorkflowBeforeToPB called before default ToPB code
type CompanyWorkflowWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyWorkflow) error
}

// CompanyWorkflowAfterToPB called after default ToPB code
type CompanyWorkflowWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyWorkflow) error
}

type CurrencyORM struct {
	Code       string `gorm:"type:varchar(255);not null"`
	CreatedAt  *time.Time
	CurrencyID uint64 `gorm:"primary_key;not null"`
	Name       string `gorm:"type:varchar(255);not null"`
	UpdatedAt  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (CurrencyORM) TableName() string {
	return "currencies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Currency) ToORM(ctx context.Context) (CurrencyORM, error) {
	to := CurrencyORM{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CurrencyID = m.CurrencyID
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(CurrencyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CurrencyORM) ToPB(ctx context.Context) (Currency, error) {
	to := Currency{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CurrencyID = m.CurrencyID
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(CurrencyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Currency the arg will be the target, the caller the one being converted from

// CurrencyBeforeToORM called before default ToORM code
type CurrencyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CurrencyORM) error
}

// CurrencyAfterToORM called after default ToORM code
type CurrencyWithAfterToORM interface {
	AfterToORM(context.Context, *CurrencyORM) error
}

// CurrencyBeforeToPB called before default ToPB code
type CurrencyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Currency) error
}

// CurrencyAfterToPB called after default ToPB code
type CurrencyWithAfterToPB interface {
	AfterToPB(context.Context, *Currency) error
}

type CompanyTaskORM struct {
	CompanyGroup *CompanyGroupORM `gorm:"foreignkey:GroupId;association_foreignkey:GroupID"`
	GroupID      uint64           `gorm:"column:group_id"`
	GroupId      *uint64
	TaskID       uint64 `gorm:"column:task_id;primary_key;not null"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyTaskORM) TableName() string {
	return "company_groups_task"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyTask) ToORM(ctx context.Context) (CompanyTaskORM, error) {
	to := CompanyTaskORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyTaskWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TaskID = m.TaskID
	to.GroupID = m.GroupID
	if m.CompanyGroup != nil {
		tempCompanyGroup, err := m.CompanyGroup.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.CompanyGroup = &tempCompanyGroup
	}
	if posthook, ok := interface{}(m).(CompanyTaskWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyTaskORM) ToPB(ctx context.Context) (CompanyTask, error) {
	to := CompanyTask{}
	var err error
	if prehook, ok := interface{}(m).(CompanyTaskWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TaskID = m.TaskID
	to.GroupID = m.GroupID
	if m.CompanyGroup != nil {
		tempCompanyGroup, err := m.CompanyGroup.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.CompanyGroup = &tempCompanyGroup
	}
	if posthook, ok := interface{}(m).(CompanyTaskWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyTask the arg will be the target, the caller the one being converted from

// CompanyTaskBeforeToORM called before default ToORM code
type CompanyTaskWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyTaskORM) error
}

// CompanyTaskAfterToORM called after default ToORM code
type CompanyTaskWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyTaskORM) error
}

// CompanyTaskBeforeToPB called before default ToPB code
type CompanyTaskWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyTask) error
}

// CompanyTaskAfterToPB called after default ToPB code
type CompanyTaskWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyTask) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateCompanyGroup executes a basic gorm create call
func DefaultCreateCompanyGroup(ctx context.Context, in *CompanyGroup, db *gorm.DB) (*CompanyGroup, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyGroupORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyGroup(ctx context.Context, in *CompanyGroup, db *gorm.DB) (*CompanyGroup, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.GroupID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyGroupORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyGroupORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyGroupORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyGroupORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyGroup(ctx context.Context, in *CompanyGroup, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.GroupID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyGroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyGroupORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyGroupSet(ctx context.Context, in []*CompanyGroup, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.GroupID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.GroupID)
	}
	if hook, ok := (interface{}(&CompanyGroupORM{})).(CompanyGroupORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("group_id in (?)", keys).Delete(&CompanyGroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyGroupORM{})).(CompanyGroupORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyGroupORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyGroup, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyGroup, *gorm.DB) error
}

// DefaultStrictUpdateCompanyGroup clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyGroup(ctx context.Context, in *CompanyGroup, db *gorm.DB) (*CompanyGroup, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyGroupORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("group_id=?", ormObj.GroupID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCompanyLimits := CompanyLimitORM{}
	if ormObj.GroupID == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompanyLimits.group_id = new(uint64)
	*filterCompanyLimits.group_id = ormObj.GroupID
	if err = db.Where(filterCompanyLimits).Delete(CompanyLimitORM{}).Error; err != nil {
		return nil, err
	}
	filterGroupLimits := GroupLimitORM{}
	if ormObj.GroupID == 0 {
		return nil, errors.EmptyIdError
	}
	filterGroupLimits.group_id = new(uint64)
	*filterGroupLimits.group_id = ormObj.GroupID
	if err = db.Where(filterGroupLimits).Delete(GroupLimitORM{}).Error; err != nil {
		return nil, err
	}
	filterGroupSubsidiaries := GroupSubsidiaryORM{}
	if ormObj.GroupID == 0 {
		return nil, errors.EmptyIdError
	}
	filterGroupSubsidiaries.group_id = new(uint64)
	*filterGroupSubsidiaries.group_id = ormObj.GroupID
	if err = db.Where(filterGroupSubsidiaries).Delete(GroupSubsidiaryORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyGroupORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyGroup executes a basic gorm update call with patch behavior
func DefaultPatchCompanyGroup(ctx context.Context, in *CompanyGroup, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyGroup, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyGroup
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyGroupWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyGroupWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyGroup(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyGroupWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyGroup(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyGroupWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyGroupWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyGroup, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyGroup, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyGroup, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyGroup, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyGroup executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyGroup(ctx context.Context, objects []*CompanyGroup, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyGroup, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyGroup, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyGroup(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyGroup(ctx context.Context, patchee *CompanyGroup, patcher *CompanyGroup, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyGroup, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"GroupID" {
			patchee.GroupID = patcher.GroupID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"HoldingCompanyID" {
			patchee.HoldingCompanyID = patcher.HoldingCompanyID
			continue
		}
		if f == prefix+"HoldingCompanyName" {
			patchee.HoldingCompanyName = patcher.HoldingCompanyName
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"GroupLimits" {
			patchee.GroupLimits = patcher.GroupLimits
			continue
		}
		if f == prefix+"CompanyLimits" {
			patchee.CompanyLimits = patcher.CompanyLimits
			continue
		}
		if f == prefix+"GroupSubsidiaries" {
			patchee.GroupSubsidiaries = patcher.GroupSubsidiaries
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyGroup executes a gorm list call
func DefaultListCompanyGroup(ctx context.Context, db *gorm.DB) ([]*CompanyGroup, error) {
	in := CompanyGroup{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyGroupORM{}, &CompanyGroup{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("group_id")
	ormResponse := []CompanyGroupORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyGroup{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyGroupORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyGroupORM) error
}

// DefaultCreateGroupLimit executes a basic gorm create call
func DefaultCreateGroupLimit(ctx context.Context, in *GroupLimit, db *gorm.DB) (*GroupLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupLimitORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadGroupLimit(ctx context.Context, in *GroupLimit, db *gorm.DB) (*GroupLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.GroupID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &GroupLimitORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupLimitORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupLimitORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupLimitORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupLimit(ctx context.Context, in *GroupLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.GroupID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupLimitORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupLimitSet(ctx context.Context, in []*GroupLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.GroupID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.GroupID)
	}
	if hook, ok := (interface{}(&GroupLimitORM{})).(GroupLimitORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("group_id in (?)", keys).Delete(&GroupLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupLimitORM{})).(GroupLimitORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupLimitORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*GroupLimit, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*GroupLimit, *gorm.DB) error
}

// DefaultStrictUpdateGroupLimit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroupLimit(ctx context.Context, in *GroupLimit, db *gorm.DB) (*GroupLimit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroupLimit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &GroupLimitORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("group_id=?", ormObj.GroupID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupLimitORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchGroupLimit executes a basic gorm update call with patch behavior
func DefaultPatchGroupLimit(ctx context.Context, in *GroupLimit, updateMask *field_mask.FieldMask, db *gorm.DB) (*GroupLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj GroupLimit
	var err error
	if hook, ok := interface{}(&pbObj).(GroupLimitWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(GroupLimitWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroupLimit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupLimitWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroupLimit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupLimitWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupLimitWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *GroupLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *GroupLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *GroupLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *GroupLimit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetGroupLimit executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroupLimit(ctx context.Context, objects []*GroupLimit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*GroupLimit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*GroupLimit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroupLimit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroupLimit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroupLimit(ctx context.Context, patchee *GroupLimit, patcher *GroupLimit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*GroupLimit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCurrency bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"GroupID" {
			patchee.GroupID = patcher.GroupID
			continue
		}
		if !updatedCurrency && strings.HasPrefix(f, prefix+"Currency.") {
			updatedCurrency = true
			if patcher.Currency == nil {
				patchee.Currency = nil
				continue
			}
			if patchee.Currency == nil {
				patchee.Currency = &Currency{}
			}
			if o, err := DefaultApplyFieldMaskCurrency(ctx, patchee.Currency, patcher.Currency, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Currency.", db); err != nil {
				return nil, err
			} else {
				patchee.Currency = o
			}
			continue
		}
		if f == prefix+"Currency" {
			updatedCurrency = true
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Limit" {
			patchee.Limit = patcher.Limit
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroupLimit executes a gorm list call
func DefaultListGroupLimit(ctx context.Context, db *gorm.DB) ([]*GroupLimit, error) {
	in := GroupLimit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &GroupLimitORM{}, &GroupLimit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("group_id")
	ormResponse := []GroupLimitORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupLimitORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*GroupLimit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupLimitORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupLimitORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]GroupLimitORM) error
}

// DefaultCreateCompanyLimit executes a basic gorm create call
func DefaultCreateCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyLimitORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyLimitORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyLimitORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyLimitORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyLimitORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyLimitORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyLimitSet(ctx context.Context, in []*CompanyLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.GroupID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.GroupID)
	}
	if hook, ok := (interface{}(&CompanyLimitORM{})).(CompanyLimitORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("group_id in (?)", keys).Delete(&CompanyLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyLimitORM{})).(CompanyLimitORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyLimitORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyLimit, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyLimit, *gorm.DB) error
}

// DefaultStrictUpdateCompanyLimit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyLimit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyLimitORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("company_id=?", ormObj.CompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyLimitORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyLimit executes a basic gorm update call with patch behavior
func DefaultPatchCompanyLimit(ctx context.Context, in *CompanyLimit, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyLimit
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyLimitWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyLimitWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyLimit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyLimitWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyLimit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyLimitWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyLimitWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyLimit executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyLimit(ctx context.Context, objects []*CompanyLimit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyLimit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyLimit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyLimit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyLimit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyLimit(ctx context.Context, patchee *CompanyLimit, patcher *CompanyLimit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyLimit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCurrency bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"GroupID" {
			patchee.GroupID = patcher.GroupID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if !updatedCurrency && strings.HasPrefix(f, prefix+"Currency.") {
			updatedCurrency = true
			if patcher.Currency == nil {
				patchee.Currency = nil
				continue
			}
			if patchee.Currency == nil {
				patchee.Currency = &Currency{}
			}
			if o, err := DefaultApplyFieldMaskCurrency(ctx, patchee.Currency, patcher.Currency, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Currency.", db); err != nil {
				return nil, err
			} else {
				patchee.Currency = o
			}
			continue
		}
		if f == prefix+"Currency" {
			updatedCurrency = true
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Limit" {
			patchee.Limit = patcher.Limit
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyLimit executes a gorm list call
func DefaultListCompanyLimit(ctx context.Context, db *gorm.DB) ([]*CompanyLimit, error) {
	in := CompanyLimit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyLimitORM{}, &CompanyLimit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("group_id")
	ormResponse := []CompanyLimitORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyLimit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyLimitORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyLimitORM) error
}

// DefaultCreateGroupSubsidiary executes a basic gorm create call
func DefaultCreateGroupSubsidiary(ctx context.Context, in *GroupSubsidiary, db *gorm.DB) (*GroupSubsidiary, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupSubsidiaryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadGroupSubsidiary(ctx context.Context, in *GroupSubsidiary, db *gorm.DB) (*GroupSubsidiary, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.GroupID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &GroupSubsidiaryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupSubsidiaryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupSubsidiaryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupSubsidiaryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupSubsidiary(ctx context.Context, in *GroupSubsidiary, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.GroupID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupSubsidiaryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupSubsidiaryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupSubsidiarySet(ctx context.Context, in []*GroupSubsidiary, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.ParentCompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.ParentCompanyID)
	}
	if hook, ok := (interface{}(&GroupSubsidiaryORM{})).(GroupSubsidiaryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("parent_company_id in (?)", keys).Delete(&GroupSubsidiaryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupSubsidiaryORM{})).(GroupSubsidiaryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupSubsidiaryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*GroupSubsidiary, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*GroupSubsidiary, *gorm.DB) error
}

// DefaultStrictUpdateGroupSubsidiary clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroupSubsidiary(ctx context.Context, in *GroupSubsidiary, db *gorm.DB) (*GroupSubsidiary, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroupSubsidiary")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &GroupSubsidiaryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("group_id=?", ormObj.GroupID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupSubsidiaryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchGroupSubsidiary executes a basic gorm update call with patch behavior
func DefaultPatchGroupSubsidiary(ctx context.Context, in *GroupSubsidiary, updateMask *field_mask.FieldMask, db *gorm.DB) (*GroupSubsidiary, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj GroupSubsidiary
	var err error
	if hook, ok := interface{}(&pbObj).(GroupSubsidiaryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(GroupSubsidiaryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroupSubsidiary(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupSubsidiaryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroupSubsidiary(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupSubsidiaryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupSubsidiaryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *GroupSubsidiary, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *GroupSubsidiary, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *GroupSubsidiary, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *GroupSubsidiary, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetGroupSubsidiary executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroupSubsidiary(ctx context.Context, objects []*GroupSubsidiary, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*GroupSubsidiary, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*GroupSubsidiary, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroupSubsidiary(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroupSubsidiary patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroupSubsidiary(ctx context.Context, patchee *GroupSubsidiary, patcher *GroupSubsidiary, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*GroupSubsidiary, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"GroupID" {
			patchee.GroupID = patcher.GroupID
			continue
		}
		if f == prefix+"ParentCompanyID" {
			patchee.ParentCompanyID = patcher.ParentCompanyID
			continue
		}
		if f == prefix+"SubsidiaryCompanyID" {
			patchee.SubsidiaryCompanyID = patcher.SubsidiaryCompanyID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroupSubsidiary executes a gorm list call
func DefaultListGroupSubsidiary(ctx context.Context, db *gorm.DB) ([]*GroupSubsidiary, error) {
	in := GroupSubsidiary{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &GroupSubsidiaryORM{}, &GroupSubsidiary{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("group_id")
	ormResponse := []GroupSubsidiaryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupSubsidiaryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*GroupSubsidiary{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupSubsidiaryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupSubsidiaryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]GroupSubsidiaryORM) error
}

// DefaultCreateCompanyWorkflow executes a basic gorm create call
func DefaultCreateCompanyWorkflow(ctx context.Context, in *CompanyWorkflow, db *gorm.DB) (*CompanyWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyWorkflowORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyWorkflow(ctx context.Context, in *CompanyWorkflow, db *gorm.DB) (*CompanyWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyWorkflowORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyWorkflowORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyWorkflowORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyWorkflowORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyWorkflow(ctx context.Context, in *CompanyWorkflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyWorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyWorkflowORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyWorkflowSet(ctx context.Context, in []*CompanyWorkflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CompanyID)
	}
	if hook, ok := (interface{}(&CompanyWorkflowORM{})).(CompanyWorkflowORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("company_id in (?)", keys).Delete(&CompanyWorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyWorkflowORM{})).(CompanyWorkflowORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyWorkflowORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyWorkflow, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyWorkflow, *gorm.DB) error
}

// DefaultStrictUpdateCompanyWorkflow clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyWorkflow(ctx context.Context, in *CompanyWorkflow, db *gorm.DB) (*CompanyWorkflow, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyWorkflow")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyWorkflowORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("company_id=?", ormObj.CompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyWorkflowORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyWorkflow executes a basic gorm update call with patch behavior
func DefaultPatchCompanyWorkflow(ctx context.Context, in *CompanyWorkflow, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyWorkflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyWorkflow
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyWorkflowWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyWorkflowWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyWorkflow(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyWorkflowWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyWorkflow(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyWorkflowWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyWorkflowWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyWorkflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyWorkflow, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyWorkflow executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyWorkflow(ctx context.Context, objects []*CompanyWorkflow, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyWorkflow, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyWorkflow, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyWorkflow(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyWorkflow patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyWorkflow(ctx context.Context, patchee *CompanyWorkflow, patcher *CompanyWorkflow, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyWorkflow, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"IsTransactionSTP" {
			patchee.IsTransactionSTP = patcher.IsTransactionSTP
			continue
		}
		if f == prefix+"IsTransactionChecker" {
			patchee.IsTransactionChecker = patcher.IsTransactionChecker
			continue
		}
		if f == prefix+"IsTransactionSigner" {
			patchee.IsTransactionSigner = patcher.IsTransactionSigner
			continue
		}
		if f == prefix+"IsTransactionReleaser" {
			patchee.IsTransactionReleaser = patcher.IsTransactionReleaser
			continue
		}
		if f == prefix+"IsNonTransactionSTP" {
			patchee.IsNonTransactionSTP = patcher.IsNonTransactionSTP
			continue
		}
		if f == prefix+"IsNonTransactionChecker" {
			patchee.IsNonTransactionChecker = patcher.IsNonTransactionChecker
			continue
		}
		if f == prefix+"IsNonTransactionSigner" {
			patchee.IsNonTransactionSigner = patcher.IsNonTransactionSigner
			continue
		}
		if f == prefix+"IsNonTransactionReleaser" {
			patchee.IsNonTransactionReleaser = patcher.IsNonTransactionReleaser
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyWorkflow executes a gorm list call
func DefaultListCompanyWorkflow(ctx context.Context, db *gorm.DB) ([]*CompanyWorkflow, error) {
	in := CompanyWorkflow{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyWorkflowORM{}, &CompanyWorkflow{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("company_id")
	ormResponse := []CompanyWorkflowORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyWorkflow{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyWorkflowORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyWorkflowORM) error
}

// DefaultCreateCurrency executes a basic gorm create call
func DefaultCreateCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CurrencyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CurrencyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CurrencyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CurrencyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCurrency(ctx context.Context, in *Currency, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CurrencyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CurrencyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCurrencySet(ctx context.Context, in []*Currency, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CurrencyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CurrencyID)
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("currency_id in (?)", keys).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CurrencyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Currency, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Currency, *gorm.DB) error
}

// DefaultStrictUpdateCurrency clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCurrency")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CurrencyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("currency_id=?", ormObj.CurrencyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CurrencyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCurrency executes a basic gorm update call with patch behavior
func DefaultPatchCurrency(ctx context.Context, in *Currency, updateMask *field_mask.FieldMask, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Currency
	var err error
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCurrency(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCurrency(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CurrencyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CurrencyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCurrency executes a bulk gorm update call with patch behavior
func DefaultPatchSetCurrency(ctx context.Context, objects []*Currency, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Currency, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Currency, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCurrency(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCurrency patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCurrency(ctx context.Context, patchee *Currency, patcher *Currency, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Currency, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCurrency executes a gorm list call
func DefaultListCurrency(ctx context.Context, db *gorm.DB) ([]*Currency, error) {
	in := Currency{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CurrencyORM{}, &Currency{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("currency_id")
	ormResponse := []CurrencyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Currency{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CurrencyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CurrencyORM) error
}

// DefaultCreateCompanyTask executes a basic gorm create call
func DefaultCreateCompanyTask(ctx context.Context, in *CompanyTask, db *gorm.DB) (*CompanyTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyTaskORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyTask(ctx context.Context, in *CompanyTask, db *gorm.DB) (*CompanyTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.TaskID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyTaskORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyTaskORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyTaskORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyTaskORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyTask(ctx context.Context, in *CompanyTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.TaskID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyTaskORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyTaskSet(ctx context.Context, in []*CompanyTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.TaskID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.TaskID)
	}
	if hook, ok := (interface{}(&CompanyTaskORM{})).(CompanyTaskORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("task_id in (?)", keys).Delete(&CompanyTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyTaskORM{})).(CompanyTaskORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyTaskORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyTask, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyTask, *gorm.DB) error
}

// DefaultStrictUpdateCompanyTask clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyTask(ctx context.Context, in *CompanyTask, db *gorm.DB) (*CompanyTask, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyTask")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyTaskORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("task_id=?", ormObj.TaskID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyTaskORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyTask executes a basic gorm update call with patch behavior
func DefaultPatchCompanyTask(ctx context.Context, in *CompanyTask, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyTask
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyTaskWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyTaskWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyTask(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyTaskWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyTask(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyTaskWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyTaskWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyTask, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyTask executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyTask(ctx context.Context, objects []*CompanyTask, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyTask, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyTask, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyTask(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyTask patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyTask(ctx context.Context, patchee *CompanyTask, patcher *CompanyTask, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyTask, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCompanyGroup bool
	for i, f := range updateMask.Paths {
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"GroupID" {
			patchee.GroupID = patcher.GroupID
			continue
		}
		if !updatedCompanyGroup && strings.HasPrefix(f, prefix+"CompanyGroup.") {
			updatedCompanyGroup = true
			if patcher.CompanyGroup == nil {
				patchee.CompanyGroup = nil
				continue
			}
			if patchee.CompanyGroup == nil {
				patchee.CompanyGroup = &CompanyGroup{}
			}
			if o, err := DefaultApplyFieldMaskCompanyGroup(ctx, patchee.CompanyGroup, patcher.CompanyGroup, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"CompanyGroup.", db); err != nil {
				return nil, err
			} else {
				patchee.CompanyGroup = o
			}
			continue
		}
		if f == prefix+"CompanyGroup" {
			updatedCompanyGroup = true
			patchee.CompanyGroup = patcher.CompanyGroup
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyTask executes a gorm list call
func DefaultListCompanyTask(ctx context.Context, db *gorm.DB) ([]*CompanyTask, error) {
	in := CompanyTask{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyTaskORM{}, &CompanyTask{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("task_id")
	ormResponse := []CompanyTaskORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyTaskORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyTask{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyTaskORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyTaskORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyTaskORM) error
}
