package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserORM struct {
	CreatedAt *time.Time
	DeletedAt *time.Time
	Id        uint64 `gorm:"primary_key;not null"`
	Password  string `gorm:"not null"`
	Role      string `gorm:"default:user;not null"`
	UpdatedAt *time.Time
	Username  string `gorm:"unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type BeneficiaryAccountORM struct {
	AccessLevel          string     `gorm:"column:AccessLevel;not null"`
	AccountAlias         string     `gorm:"column:AccountAlias;not null"`
	AccountCurrency      string     `gorm:"column:AccountCurrency;not null"`
	AccountName          string     `gorm:"column:AccountName;not null"`
	AccountNumber        string     `gorm:"column:AccountNumber;not null"`
	AccountType          string     `gorm:"column:AccountType;not null"`
	BeneficiaryAccountID uint64     `gorm:"column:BeneficiaryAccountID;primary_key;not null;auto_increment"`
	Bic                  string     `gorm:"column:Bic"`
	CompanyID            uint64     `gorm:"column:CompanyID;not null"`
	CompanyName          string     `gorm:"column:CompanyName;not null"`
	Country              string     `gorm:"column:Country"`
	CreatedAt            *time.Time `gorm:"column:CreatedAt"`
	CreatedByID          uint64     `gorm:"column:CreatedByID;not null"`
	DeletedAt            *time.Time `gorm:"column:DeletedAt"`
	DeletedByID          uint64     `gorm:"column:DeletedByID"`
	IsOwnedByCompany     string     `gorm:"column:IsOwnedByCompany;not null"`
	MasterBankID         string     `gorm:"column:MasterBankID;not null"`
	MasterBankName       string     `gorm:"column:MasterBankName;not null"`
	UpdatedAt            *time.Time `gorm:"column:UpdatedAt"`
	UpdatedByID          uint64     `gorm:"column:UpdatedByID;not null"`
}

// TableName overrides the default tablename generated by GORM
func (BeneficiaryAccountORM) TableName() string {
	return "beneficiary_bank_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BeneficiaryAccount) ToORM(ctx context.Context) (BeneficiaryAccountORM, error) {
	to := BeneficiaryAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BeneficiaryAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BeneficiaryAccountID = m.BeneficiaryAccountID
	to.CompanyID = m.CompanyID
	to.Country = m.Country
	to.Bic = m.Bic
	to.MasterBankID = m.MasterBankID
	to.AccountNumber = m.AccountNumber
	to.AccountAlias = m.AccountAlias
	to.AccountName = m.AccountName
	to.AccountType = m.AccountType
	to.AccountCurrency = m.AccountCurrency
	to.AccessLevel = m.AccessLevel
	to.IsOwnedByCompany = m.IsOwnedByCompany
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	to.CompanyName = m.CompanyName
	to.MasterBankName = m.MasterBankName
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(BeneficiaryAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BeneficiaryAccountORM) ToPB(ctx context.Context) (BeneficiaryAccount, error) {
	to := BeneficiaryAccount{}
	var err error
	if prehook, ok := interface{}(m).(BeneficiaryAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BeneficiaryAccountID = m.BeneficiaryAccountID
	to.CompanyID = m.CompanyID
	to.Country = m.Country
	to.Bic = m.Bic
	to.MasterBankID = m.MasterBankID
	to.AccountNumber = m.AccountNumber
	to.AccountAlias = m.AccountAlias
	to.AccountName = m.AccountName
	to.AccountType = m.AccountType
	to.AccountCurrency = m.AccountCurrency
	to.AccessLevel = m.AccessLevel
	to.IsOwnedByCompany = m.IsOwnedByCompany
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	to.CompanyName = m.CompanyName
	to.MasterBankName = m.MasterBankName
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(BeneficiaryAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BeneficiaryAccount the arg will be the target, the caller the one being converted from

// BeneficiaryAccountBeforeToORM called before default ToORM code
type BeneficiaryAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BeneficiaryAccountORM) error
}

// BeneficiaryAccountAfterToORM called after default ToORM code
type BeneficiaryAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BeneficiaryAccountORM) error
}

// BeneficiaryAccountBeforeToPB called before default ToPB code
type BeneficiaryAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BeneficiaryAccount) error
}

// BeneficiaryAccountAfterToPB called after default ToPB code
type BeneficiaryAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BeneficiaryAccount) error
}

type BeneficiaryBankORM struct {
	BankCode          string     `gorm:"column:BankCode"`
	BankDesc          string     `gorm:"column:BankDesc;not null"`
	BankName          string     `gorm:"column:BankName;not null"`
	BeneficiaryBankID uint64     `gorm:"column:BeneficiaryBankID;primary_key;not null;auto_increment"`
	Country           string     `gorm:"column:Country"`
	CreatedAt         *time.Time `gorm:"column:CreatedAt"`
	CreatedByID       uint64     `gorm:"column:CreatedByID;not null"`
	UpdatedAt         *time.Time `gorm:"column:UpdatedAt"`
	UpdatedByID       uint64     `gorm:"column:UpdatedByID;not null"`
}

// TableName overrides the default tablename generated by GORM
func (BeneficiaryBankORM) TableName() string {
	return "beneficiary_banks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BeneficiaryBank) ToORM(ctx context.Context) (BeneficiaryBankORM, error) {
	to := BeneficiaryBankORM{}
	var err error
	if prehook, ok := interface{}(m).(BeneficiaryBankWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BeneficiaryBankID = m.BeneficiaryBankID
	to.BankCode = m.BankCode
	to.BankName = m.BankName
	to.BankDesc = m.BankDesc
	to.Country = m.Country
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(BeneficiaryBankWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BeneficiaryBankORM) ToPB(ctx context.Context) (BeneficiaryBank, error) {
	to := BeneficiaryBank{}
	var err error
	if prehook, ok := interface{}(m).(BeneficiaryBankWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.BeneficiaryBankID = m.BeneficiaryBankID
	to.BankCode = m.BankCode
	to.BankName = m.BankName
	to.BankDesc = m.BankDesc
	to.Country = m.Country
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(BeneficiaryBankWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BeneficiaryBank the arg will be the target, the caller the one being converted from

// BeneficiaryBankBeforeToORM called before default ToORM code
type BeneficiaryBankWithBeforeToORM interface {
	BeforeToORM(context.Context, *BeneficiaryBankORM) error
}

// BeneficiaryBankAfterToORM called after default ToORM code
type BeneficiaryBankWithAfterToORM interface {
	AfterToORM(context.Context, *BeneficiaryBankORM) error
}

// BeneficiaryBankBeforeToPB called before default ToPB code
type BeneficiaryBankWithBeforeToPB interface {
	BeforeToPB(context.Context, *BeneficiaryBank) error
}

// BeneficiaryBankAfterToPB called after default ToPB code
type BeneficiaryBankWithAfterToPB interface {
	AfterToPB(context.Context, *BeneficiaryBank) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateBeneficiaryAccount executes a basic gorm create call
func DefaultCreateBeneficiaryAccount(ctx context.Context, in *BeneficiaryAccount, db *gorm.DB) (*BeneficiaryAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BeneficiaryAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBeneficiaryAccount(ctx context.Context, in *BeneficiaryAccount, db *gorm.DB) (*BeneficiaryAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.BeneficiaryAccountID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BeneficiaryAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BeneficiaryAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BeneficiaryAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BeneficiaryAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBeneficiaryAccount(ctx context.Context, in *BeneficiaryAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.BeneficiaryAccountID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BeneficiaryAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BeneficiaryAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBeneficiaryAccountSet(ctx context.Context, in []*BeneficiaryAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.BeneficiaryAccountID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.BeneficiaryAccountID)
	}
	if hook, ok := (interface{}(&BeneficiaryAccountORM{})).(BeneficiaryAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("beneficiary_account_id in (?)", keys).Delete(&BeneficiaryAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BeneficiaryAccountORM{})).(BeneficiaryAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BeneficiaryAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BeneficiaryAccount, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BeneficiaryAccount, *gorm.DB) error
}

// DefaultStrictUpdateBeneficiaryAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBeneficiaryAccount(ctx context.Context, in *BeneficiaryAccount, db *gorm.DB) (*BeneficiaryAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBeneficiaryAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BeneficiaryAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("BeneficiaryAccountID=?", ormObj.BeneficiaryAccountID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BeneficiaryAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBeneficiaryAccount executes a basic gorm update call with patch behavior
func DefaultPatchBeneficiaryAccount(ctx context.Context, in *BeneficiaryAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*BeneficiaryAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BeneficiaryAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BeneficiaryAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(BeneficiaryAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBeneficiaryAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BeneficiaryAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBeneficiaryAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BeneficiaryAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BeneficiaryAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BeneficiaryAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BeneficiaryAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BeneficiaryAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BeneficiaryAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBeneficiaryAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBeneficiaryAccount(ctx context.Context, objects []*BeneficiaryAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BeneficiaryAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BeneficiaryAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBeneficiaryAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBeneficiaryAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBeneficiaryAccount(ctx context.Context, patchee *BeneficiaryAccount, patcher *BeneficiaryAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BeneficiaryAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"BeneficiaryAccountID" {
			patchee.BeneficiaryAccountID = patcher.BeneficiaryAccountID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"Bic" {
			patchee.Bic = patcher.Bic
			continue
		}
		if f == prefix+"MasterBankID" {
			patchee.MasterBankID = patcher.MasterBankID
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"AccountAlias" {
			patchee.AccountAlias = patcher.AccountAlias
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"AccountCurrency" {
			patchee.AccountCurrency = patcher.AccountCurrency
			continue
		}
		if f == prefix+"AccessLevel" {
			patchee.AccessLevel = patcher.AccessLevel
			continue
		}
		if f == prefix+"IsOwnedByCompany" {
			patchee.IsOwnedByCompany = patcher.IsOwnedByCompany
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"MasterBankName" {
			patchee.MasterBankName = patcher.MasterBankName
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBeneficiaryAccount executes a gorm list call
func DefaultListBeneficiaryAccount(ctx context.Context, db *gorm.DB) ([]*BeneficiaryAccount, error) {
	in := BeneficiaryAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BeneficiaryAccountORM{}, &BeneficiaryAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("BeneficiaryAccountID")
	ormResponse := []BeneficiaryAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BeneficiaryAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BeneficiaryAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BeneficiaryAccountORM) error
}

// DefaultCreateBeneficiaryBank executes a basic gorm create call
func DefaultCreateBeneficiaryBank(ctx context.Context, in *BeneficiaryBank, db *gorm.DB) (*BeneficiaryBank, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BeneficiaryBankORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBeneficiaryBank(ctx context.Context, in *BeneficiaryBank, db *gorm.DB) (*BeneficiaryBank, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.BeneficiaryBankID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BeneficiaryBankORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BeneficiaryBankORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BeneficiaryBankORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BeneficiaryBankORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBeneficiaryBank(ctx context.Context, in *BeneficiaryBank, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.BeneficiaryBankID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BeneficiaryBankORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BeneficiaryBankORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBeneficiaryBankSet(ctx context.Context, in []*BeneficiaryBank, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.BeneficiaryBankID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.BeneficiaryBankID)
	}
	if hook, ok := (interface{}(&BeneficiaryBankORM{})).(BeneficiaryBankORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("beneficiary_bank_id in (?)", keys).Delete(&BeneficiaryBankORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BeneficiaryBankORM{})).(BeneficiaryBankORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BeneficiaryBankORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BeneficiaryBank, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BeneficiaryBank, *gorm.DB) error
}

// DefaultStrictUpdateBeneficiaryBank clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBeneficiaryBank(ctx context.Context, in *BeneficiaryBank, db *gorm.DB) (*BeneficiaryBank, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBeneficiaryBank")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BeneficiaryBankORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("BeneficiaryBankID=?", ormObj.BeneficiaryBankID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BeneficiaryBankORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBeneficiaryBank executes a basic gorm update call with patch behavior
func DefaultPatchBeneficiaryBank(ctx context.Context, in *BeneficiaryBank, updateMask *field_mask.FieldMask, db *gorm.DB) (*BeneficiaryBank, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BeneficiaryBank
	var err error
	if hook, ok := interface{}(&pbObj).(BeneficiaryBankWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(BeneficiaryBankWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBeneficiaryBank(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BeneficiaryBankWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBeneficiaryBank(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BeneficiaryBankWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BeneficiaryBankWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BeneficiaryBank, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BeneficiaryBank, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BeneficiaryBank, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BeneficiaryBank, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBeneficiaryBank executes a bulk gorm update call with patch behavior
func DefaultPatchSetBeneficiaryBank(ctx context.Context, objects []*BeneficiaryBank, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BeneficiaryBank, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BeneficiaryBank, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBeneficiaryBank(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBeneficiaryBank patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBeneficiaryBank(ctx context.Context, patchee *BeneficiaryBank, patcher *BeneficiaryBank, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BeneficiaryBank, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"BeneficiaryBankID" {
			patchee.BeneficiaryBankID = patcher.BeneficiaryBankID
			continue
		}
		if f == prefix+"BankCode" {
			patchee.BankCode = patcher.BankCode
			continue
		}
		if f == prefix+"BankName" {
			patchee.BankName = patcher.BankName
			continue
		}
		if f == prefix+"BankDesc" {
			patchee.BankDesc = patcher.BankDesc
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBeneficiaryBank executes a gorm list call
func DefaultListBeneficiaryBank(ctx context.Context, db *gorm.DB) ([]*BeneficiaryBank, error) {
	in := BeneficiaryBank{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BeneficiaryBankORM{}, &BeneficiaryBank{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("BeneficiaryBankID")
	ormResponse := []BeneficiaryBankORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BeneficiaryBankORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BeneficiaryBank{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BeneficiaryBankORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BeneficiaryBankORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BeneficiaryBankORM) error
}
