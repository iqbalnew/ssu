package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type BulkTransferTransactionORM struct {
	CreatedAt            *time.Time `gorm:"not null"`
	Data                 string     `gorm:"type:jsonb"`
	Id                   uint64     `gorm:"primary_key;not null"`
	TaskID               uint64
	TransactionID        string
	TransactionServiceID uint64
	UpdatedAt            *time.Time `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (BulkTransferTransactionORM) TableName() string {
	return "bulk_transfer_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BulkTransferTransaction) ToORM(ctx context.Context) (BulkTransferTransactionORM, error) {
	to := BulkTransferTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(BulkTransferTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.TransactionServiceID = m.TransactionServiceID
	to.Data = m.Data
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(BulkTransferTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BulkTransferTransactionORM) ToPB(ctx context.Context) (BulkTransferTransaction, error) {
	to := BulkTransferTransaction{}
	var err error
	if prehook, ok := interface{}(m).(BulkTransferTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.TransactionServiceID = m.TransactionServiceID
	to.Data = m.Data
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(BulkTransferTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BulkTransferTransaction the arg will be the target, the caller the one being converted from

// BulkTransferTransactionBeforeToORM called before default ToORM code
type BulkTransferTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *BulkTransferTransactionORM) error
}

// BulkTransferTransactionAfterToORM called after default ToORM code
type BulkTransferTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *BulkTransferTransactionORM) error
}

// BulkTransferTransactionBeforeToPB called before default ToPB code
type BulkTransferTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *BulkTransferTransaction) error
}

// BulkTransferTransactionAfterToPB called after default ToPB code
type BulkTransferTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *BulkTransferTransaction) error
}

type BulkTransferItemORM struct {
	BeneficiaryAccount string
	CreatedAt          *time.Time `gorm:"not null"`
	Data               string     `gorm:"type:jsonb"`
	Id                 uint64     `gorm:"primary_key;not null"`
	InquiryResult      string     `gorm:"type:jsonb"`
	InquiryValid       bool
	TaskID             uint64
	TransferResult     string `gorm:"type:jsonb"`
	TransferValid      bool
	UpdatedAt          *time.Time `gorm:"not null"`
	UserID             uint64
	Validation         string `gorm:"type:jsonb"`
	ValidationValid    bool
}

// TableName overrides the default tablename generated by GORM
func (BulkTransferItemORM) TableName() string {
	return "bulk_transfer_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BulkTransferItem) ToORM(ctx context.Context) (BulkTransferItemORM, error) {
	to := BulkTransferItemORM{}
	var err error
	if prehook, ok := interface{}(m).(BulkTransferItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	to.Validation = m.Validation
	to.InquiryResult = m.InquiryResult
	to.TransferResult = m.TransferResult
	to.ValidationValid = m.ValidationValid
	to.InquiryValid = m.InquiryValid
	to.TransferValid = m.TransferValid
	to.BeneficiaryAccount = m.BeneficiaryAccount
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(BulkTransferItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BulkTransferItemORM) ToPB(ctx context.Context) (BulkTransferItem, error) {
	to := BulkTransferItem{}
	var err error
	if prehook, ok := interface{}(m).(BulkTransferItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	to.Validation = m.Validation
	to.InquiryResult = m.InquiryResult
	to.TransferResult = m.TransferResult
	to.ValidationValid = m.ValidationValid
	to.InquiryValid = m.InquiryValid
	to.TransferValid = m.TransferValid
	to.BeneficiaryAccount = m.BeneficiaryAccount
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(BulkTransferItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BulkTransferItem the arg will be the target, the caller the one being converted from

// BulkTransferItemBeforeToORM called before default ToORM code
type BulkTransferItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *BulkTransferItemORM) error
}

// BulkTransferItemAfterToORM called after default ToORM code
type BulkTransferItemWithAfterToORM interface {
	AfterToORM(context.Context, *BulkTransferItemORM) error
}

// BulkTransferItemBeforeToPB called before default ToPB code
type BulkTransferItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *BulkTransferItem) error
}

// BulkTransferItemAfterToPB called after default ToPB code
type BulkTransferItemWithAfterToPB interface {
	AfterToPB(context.Context, *BulkTransferItem) error
}

type MassInquiryJobORM struct {
	Comment   string
	CreatedAt *time.Time `gorm:"not null"`
	Data      string     `gorm:"type:jsonb"`
	Id        uint64     `gorm:"primary_key;not null"`
	InQueue   string
	Retry     uint64
	RunAt     *time.Time
	TaskID    uint64
	UpdatedAt *time.Time `gorm:"not null"`
	UserID    uint64
}

// TableName overrides the default tablename generated by GORM
func (MassInquiryJobORM) TableName() string {
	return "mass_inquiry_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MassInquiryJob) ToORM(ctx context.Context) (MassInquiryJobORM, error) {
	to := MassInquiryJobORM{}
	var err error
	if prehook, ok := interface{}(m).(MassInquiryJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MassInquiryJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MassInquiryJobORM) ToPB(ctx context.Context) (MassInquiryJob, error) {
	to := MassInquiryJob{}
	var err error
	if prehook, ok := interface{}(m).(MassInquiryJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.Data = m.Data
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(MassInquiryJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MassInquiryJob the arg will be the target, the caller the one being converted from

// MassInquiryJobBeforeToORM called before default ToORM code
type MassInquiryJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *MassInquiryJobORM) error
}

// MassInquiryJobAfterToORM called after default ToORM code
type MassInquiryJobWithAfterToORM interface {
	AfterToORM(context.Context, *MassInquiryJobORM) error
}

// MassInquiryJobBeforeToPB called before default ToPB code
type MassInquiryJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *MassInquiryJob) error
}

// MassInquiryJobAfterToPB called after default ToPB code
type MassInquiryJobWithAfterToPB interface {
	AfterToPB(context.Context, *MassInquiryJob) error
}

type MassTransferJobORM struct {
	Comment   string
	CompanyID uint64
	CreatedAt *time.Time `gorm:"not null"`
	Data      string     `gorm:"type:jsonb"`
	Id        uint64     `gorm:"primary_key;not null"`
	InQueue   string
	Retry     uint64
	RunAt     *time.Time
	TaskID    uint64
	UpdatedAt *time.Time `gorm:"not null"`
	UserID    uint64
}

// TableName overrides the default tablename generated by GORM
func (MassTransferJobORM) TableName() string {
	return "mass_transfer_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MassTransferJob) ToORM(ctx context.Context) (MassTransferJobORM, error) {
	to := MassTransferJobORM{}
	var err error
	if prehook, ok := interface{}(m).(MassTransferJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MassTransferJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MassTransferJobORM) ToPB(ctx context.Context) (MassTransferJob, error) {
	to := MassTransferJob{}
	var err error
	if prehook, ok := interface{}(m).(MassTransferJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserID = m.UserID
	to.TaskID = m.TaskID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(MassTransferJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MassTransferJob the arg will be the target, the caller the one being converted from

// MassTransferJobBeforeToORM called before default ToORM code
type MassTransferJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *MassTransferJobORM) error
}

// MassTransferJobAfterToORM called after default ToORM code
type MassTransferJobWithAfterToORM interface {
	AfterToORM(context.Context, *MassTransferJobORM) error
}

// MassTransferJobBeforeToPB called before default ToPB code
type MassTransferJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *MassTransferJob) error
}

// MassTransferJobAfterToPB called after default ToPB code
type MassTransferJobWithAfterToPB interface {
	AfterToPB(context.Context, *MassTransferJob) error
}

type CreateMassTransferJobORM struct {
	Comment   string
	CreatedAt *time.Time `gorm:"not null"`
	Id        uint64     `gorm:"primary_key;not null"`
	InQueue   string
	Retry     uint64
	RunAt     *time.Time
	Success   bool
	TaskID    uint64
	UpdatedAt *time.Time `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (CreateMassTransferJobORM) TableName() string {
	return "create_mass_transfer_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreateMassTransferJob) ToORM(ctx context.Context) (CreateMassTransferJobORM, error) {
	to := CreateMassTransferJobORM{}
	var err error
	if prehook, ok := interface{}(m).(CreateMassTransferJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.Success = m.Success
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(CreateMassTransferJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreateMassTransferJobORM) ToPB(ctx context.Context) (CreateMassTransferJob, error) {
	to := CreateMassTransferJob{}
	var err error
	if prehook, ok := interface{}(m).(CreateMassTransferJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.Success = m.Success
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Comment = m.Comment
	to.Retry = m.Retry
	to.InQueue = m.InQueue
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(CreateMassTransferJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreateMassTransferJob the arg will be the target, the caller the one being converted from

// CreateMassTransferJobBeforeToORM called before default ToORM code
type CreateMassTransferJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreateMassTransferJobORM) error
}

// CreateMassTransferJobAfterToORM called after default ToORM code
type CreateMassTransferJobWithAfterToORM interface {
	AfterToORM(context.Context, *CreateMassTransferJobORM) error
}

// CreateMassTransferJobBeforeToPB called before default ToPB code
type CreateMassTransferJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreateMassTransferJob) error
}

// CreateMassTransferJobAfterToPB called after default ToPB code
type CreateMassTransferJobWithAfterToPB interface {
	AfterToPB(context.Context, *CreateMassTransferJob) error
}

type FileCheckingJobORM struct {
	Comment       string
	CompanyID     uint64
	CreatedAt     *time.Time `gorm:"not null"`
	CreatedByID   uint64
	Data          string `gorm:"type:jsonb"`
	FileName      string
	Id            uint64 `gorm:"primary_key;not null"`
	InQueue       string
	Retry         uint64
	RunAt         *time.Time
	Success       bool
	TaskID        uint64
	TransactionID string
	UpdatedAt     *time.Time `gorm:"not null"`
	UpdatedByID   uint64
}

// TableName overrides the default tablename generated by GORM
func (FileCheckingJobORM) TableName() string {
	return "file_checking_jobs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FileCheckingJob) ToORM(ctx context.Context) (FileCheckingJobORM, error) {
	to := FileCheckingJobORM{}
	var err error
	if prehook, ok := interface{}(m).(FileCheckingJobWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	to.FileName = m.FileName
	to.Success = m.Success
	if m.RunAt != nil {
		t := m.RunAt.AsTime()
		to.RunAt = &t
	}
	to.Retry = m.Retry
	to.Comment = m.Comment
	to.InQueue = m.InQueue
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(FileCheckingJobWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FileCheckingJobORM) ToPB(ctx context.Context) (FileCheckingJob, error) {
	to := FileCheckingJob{}
	var err error
	if prehook, ok := interface{}(m).(FileCheckingJobWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaskID = m.TaskID
	to.TransactionID = m.TransactionID
	to.CompanyID = m.CompanyID
	to.Data = m.Data
	to.FileName = m.FileName
	to.Success = m.Success
	if m.RunAt != nil {
		to.RunAt = timestamppb.New(*m.RunAt)
	}
	to.Retry = m.Retry
	to.Comment = m.Comment
	to.InQueue = m.InQueue
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(FileCheckingJobWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FileCheckingJob the arg will be the target, the caller the one being converted from

// FileCheckingJobBeforeToORM called before default ToORM code
type FileCheckingJobWithBeforeToORM interface {
	BeforeToORM(context.Context, *FileCheckingJobORM) error
}

// FileCheckingJobAfterToORM called after default ToORM code
type FileCheckingJobWithAfterToORM interface {
	AfterToORM(context.Context, *FileCheckingJobORM) error
}

// FileCheckingJobBeforeToPB called before default ToPB code
type FileCheckingJobWithBeforeToPB interface {
	BeforeToPB(context.Context, *FileCheckingJob) error
}

// FileCheckingJobAfterToPB called after default ToPB code
type FileCheckingJobWithAfterToPB interface {
	AfterToPB(context.Context, *FileCheckingJob) error
}

type UploadedFileNameORM struct {
	CompanyID        uint64
	CreatedAt        *time.Time `gorm:"not null"`
	Finished         bool
	Id               uint64 `gorm:"primary_key;not null"`
	OriginalFileName string
	UpdatedAt        *time.Time `gorm:"not null"`
	UploadedFileName string     `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (UploadedFileNameORM) TableName() string {
	return "uploaded_file_names"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UploadedFileName) ToORM(ctx context.Context) (UploadedFileNameORM, error) {
	to := UploadedFileNameORM{}
	var err error
	if prehook, ok := interface{}(m).(UploadedFileNameWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UploadedFileName = m.UploadedFileName
	to.OriginalFileName = m.OriginalFileName
	to.CompanyID = m.CompanyID
	to.Finished = m.Finished
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(UploadedFileNameWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UploadedFileNameORM) ToPB(ctx context.Context) (UploadedFileName, error) {
	to := UploadedFileName{}
	var err error
	if prehook, ok := interface{}(m).(UploadedFileNameWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UploadedFileName = m.UploadedFileName
	to.OriginalFileName = m.OriginalFileName
	to.CompanyID = m.CompanyID
	to.Finished = m.Finished
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(UploadedFileNameWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UploadedFileName the arg will be the target, the caller the one being converted from

// UploadedFileNameBeforeToORM called before default ToORM code
type UploadedFileNameWithBeforeToORM interface {
	BeforeToORM(context.Context, *UploadedFileNameORM) error
}

// UploadedFileNameAfterToORM called after default ToORM code
type UploadedFileNameWithAfterToORM interface {
	AfterToORM(context.Context, *UploadedFileNameORM) error
}

// UploadedFileNameBeforeToPB called before default ToPB code
type UploadedFileNameWithBeforeToPB interface {
	BeforeToPB(context.Context, *UploadedFileName) error
}

// UploadedFileNameAfterToPB called after default ToPB code
type UploadedFileNameWithAfterToPB interface {
	AfterToPB(context.Context, *UploadedFileName) error
}

// DefaultCreateBulkTransferTransaction executes a basic gorm create call
func DefaultCreateBulkTransferTransaction(ctx context.Context, in *BulkTransferTransaction, db *gorm.DB) (*BulkTransferTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BulkTransferTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBulkTransferTransaction(ctx context.Context, in *BulkTransferTransaction, db *gorm.DB) (*BulkTransferTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BulkTransferTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BulkTransferTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BulkTransferTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BulkTransferTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBulkTransferTransaction(ctx context.Context, in *BulkTransferTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BulkTransferTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BulkTransferTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBulkTransferTransactionSet(ctx context.Context, in []*BulkTransferTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BulkTransferTransactionORM{})).(BulkTransferTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BulkTransferTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BulkTransferTransactionORM{})).(BulkTransferTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BulkTransferTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BulkTransferTransaction, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BulkTransferTransaction, *gorm.DB) error
}

// DefaultStrictUpdateBulkTransferTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBulkTransferTransaction(ctx context.Context, in *BulkTransferTransaction, db *gorm.DB) (*BulkTransferTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBulkTransferTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BulkTransferTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BulkTransferTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBulkTransferTransaction executes a basic gorm update call with patch behavior
func DefaultPatchBulkTransferTransaction(ctx context.Context, in *BulkTransferTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*BulkTransferTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BulkTransferTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(BulkTransferTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBulkTransferTransaction(ctx, &BulkTransferTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BulkTransferTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBulkTransferTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BulkTransferTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBulkTransferTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BulkTransferTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BulkTransferTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BulkTransferTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BulkTransferTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BulkTransferTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BulkTransferTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBulkTransferTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetBulkTransferTransaction(ctx context.Context, objects []*BulkTransferTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BulkTransferTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BulkTransferTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBulkTransferTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBulkTransferTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBulkTransferTransaction(ctx context.Context, patchee *BulkTransferTransaction, patcher *BulkTransferTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BulkTransferTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"TransactionID" {
			patchee.TransactionID = patcher.TransactionID
			continue
		}
		if f == prefix+"TransactionServiceID" {
			patchee.TransactionServiceID = patcher.TransactionServiceID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBulkTransferTransaction executes a gorm list call
func DefaultListBulkTransferTransaction(ctx context.Context, db *gorm.DB) ([]*BulkTransferTransaction, error) {
	in := BulkTransferTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BulkTransferTransactionORM{}, &BulkTransferTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BulkTransferTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BulkTransferTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BulkTransferTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BulkTransferTransactionORM) error
}

// DefaultCreateBulkTransferItem executes a basic gorm create call
func DefaultCreateBulkTransferItem(ctx context.Context, in *BulkTransferItem, db *gorm.DB) (*BulkTransferItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BulkTransferItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBulkTransferItem(ctx context.Context, in *BulkTransferItem, db *gorm.DB) (*BulkTransferItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BulkTransferItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BulkTransferItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BulkTransferItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BulkTransferItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBulkTransferItem(ctx context.Context, in *BulkTransferItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BulkTransferItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BulkTransferItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBulkTransferItemSet(ctx context.Context, in []*BulkTransferItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BulkTransferItemORM{})).(BulkTransferItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BulkTransferItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BulkTransferItemORM{})).(BulkTransferItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BulkTransferItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BulkTransferItem, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BulkTransferItem, *gorm.DB) error
}

// DefaultStrictUpdateBulkTransferItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBulkTransferItem(ctx context.Context, in *BulkTransferItem, db *gorm.DB) (*BulkTransferItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBulkTransferItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BulkTransferItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BulkTransferItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBulkTransferItem executes a basic gorm update call with patch behavior
func DefaultPatchBulkTransferItem(ctx context.Context, in *BulkTransferItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*BulkTransferItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BulkTransferItem
	var err error
	if hook, ok := interface{}(&pbObj).(BulkTransferItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBulkTransferItem(ctx, &BulkTransferItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BulkTransferItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBulkTransferItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BulkTransferItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBulkTransferItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BulkTransferItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BulkTransferItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BulkTransferItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BulkTransferItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BulkTransferItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BulkTransferItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBulkTransferItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetBulkTransferItem(ctx context.Context, objects []*BulkTransferItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BulkTransferItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BulkTransferItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBulkTransferItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBulkTransferItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBulkTransferItem(ctx context.Context, patchee *BulkTransferItem, patcher *BulkTransferItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BulkTransferItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if f == prefix+"Validation" {
			patchee.Validation = patcher.Validation
			continue
		}
		if f == prefix+"InquiryResult" {
			patchee.InquiryResult = patcher.InquiryResult
			continue
		}
		if f == prefix+"TransferResult" {
			patchee.TransferResult = patcher.TransferResult
			continue
		}
		if f == prefix+"ValidationValid" {
			patchee.ValidationValid = patcher.ValidationValid
			continue
		}
		if f == prefix+"InquiryValid" {
			patchee.InquiryValid = patcher.InquiryValid
			continue
		}
		if f == prefix+"TransferValid" {
			patchee.TransferValid = patcher.TransferValid
			continue
		}
		if f == prefix+"BeneficiaryAccount" {
			patchee.BeneficiaryAccount = patcher.BeneficiaryAccount
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBulkTransferItem executes a gorm list call
func DefaultListBulkTransferItem(ctx context.Context, db *gorm.DB) ([]*BulkTransferItem, error) {
	in := BulkTransferItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BulkTransferItemORM{}, &BulkTransferItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BulkTransferItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BulkTransferItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BulkTransferItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BulkTransferItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BulkTransferItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BulkTransferItemORM) error
}

// DefaultCreateMassInquiryJob executes a basic gorm create call
func DefaultCreateMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MassInquiryJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MassInquiryJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MassInquiryJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MassInquiryJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MassInquiryJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MassInquiryJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MassInquiryJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMassInquiryJobSet(ctx context.Context, in []*MassInquiryJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MassInquiryJobORM{})).(MassInquiryJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MassInquiryJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MassInquiryJobORM{})).(MassInquiryJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MassInquiryJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MassInquiryJob, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MassInquiryJob, *gorm.DB) error
}

// DefaultStrictUpdateMassInquiryJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMassInquiryJob(ctx context.Context, in *MassInquiryJob, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMassInquiryJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MassInquiryJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MassInquiryJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMassInquiryJob executes a basic gorm update call with patch behavior
func DefaultPatchMassInquiryJob(ctx context.Context, in *MassInquiryJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*MassInquiryJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MassInquiryJob
	var err error
	if hook, ok := interface{}(&pbObj).(MassInquiryJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMassInquiryJob(ctx, &MassInquiryJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MassInquiryJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMassInquiryJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MassInquiryJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMassInquiryJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MassInquiryJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MassInquiryJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MassInquiryJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMassInquiryJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetMassInquiryJob(ctx context.Context, objects []*MassInquiryJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MassInquiryJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MassInquiryJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMassInquiryJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMassInquiryJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMassInquiryJob(ctx context.Context, patchee *MassInquiryJob, patcher *MassInquiryJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MassInquiryJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMassInquiryJob executes a gorm list call
func DefaultListMassInquiryJob(ctx context.Context, db *gorm.DB) ([]*MassInquiryJob, error) {
	in := MassInquiryJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MassInquiryJobORM{}, &MassInquiryJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MassInquiryJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassInquiryJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MassInquiryJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MassInquiryJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassInquiryJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MassInquiryJobORM) error
}

// DefaultCreateMassTransferJob executes a basic gorm create call
func DefaultCreateMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MassTransferJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MassTransferJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MassTransferJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MassTransferJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MassTransferJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MassTransferJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMassTransferJobSet(ctx context.Context, in []*MassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MassTransferJobORM{})).(MassTransferJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MassTransferJobORM{})).(MassTransferJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MassTransferJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MassTransferJob, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MassTransferJob, *gorm.DB) error
}

// DefaultStrictUpdateMassTransferJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMassTransferJob(ctx context.Context, in *MassTransferJob, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMassTransferJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MassTransferJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MassTransferJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMassTransferJob executes a basic gorm update call with patch behavior
func DefaultPatchMassTransferJob(ctx context.Context, in *MassTransferJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*MassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MassTransferJob
	var err error
	if hook, ok := interface{}(&pbObj).(MassTransferJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMassTransferJob(ctx, &MassTransferJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MassTransferJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMassTransferJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MassTransferJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMassTransferJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MassTransferJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MassTransferJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MassTransferJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMassTransferJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetMassTransferJob(ctx context.Context, objects []*MassTransferJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MassTransferJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MassTransferJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMassTransferJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMassTransferJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMassTransferJob(ctx context.Context, patchee *MassTransferJob, patcher *MassTransferJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MassTransferJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMassTransferJob executes a gorm list call
func DefaultListMassTransferJob(ctx context.Context, db *gorm.DB) ([]*MassTransferJob, error) {
	in := MassTransferJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MassTransferJobORM{}, &MassTransferJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MassTransferJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MassTransferJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MassTransferJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MassTransferJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MassTransferJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MassTransferJobORM) error
}

// DefaultCreateCreateMassTransferJob executes a basic gorm create call
func DefaultCreateCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreateMassTransferJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreateMassTransferJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreateMassTransferJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreateMassTransferJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreateMassTransferJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreateMassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreateMassTransferJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreateMassTransferJobSet(ctx context.Context, in []*CreateMassTransferJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreateMassTransferJobORM{})).(CreateMassTransferJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreateMassTransferJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreateMassTransferJobORM{})).(CreateMassTransferJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreateMassTransferJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreateMassTransferJob, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreateMassTransferJob, *gorm.DB) error
}

// DefaultStrictUpdateCreateMassTransferJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreateMassTransferJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreateMassTransferJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreateMassTransferJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreateMassTransferJob executes a basic gorm update call with patch behavior
func DefaultPatchCreateMassTransferJob(ctx context.Context, in *CreateMassTransferJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreateMassTransferJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreateMassTransferJob
	var err error
	if hook, ok := interface{}(&pbObj).(CreateMassTransferJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreateMassTransferJob(ctx, &CreateMassTransferJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreateMassTransferJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreateMassTransferJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreateMassTransferJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreateMassTransferJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreateMassTransferJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreateMassTransferJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreateMassTransferJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreateMassTransferJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreateMassTransferJob(ctx context.Context, objects []*CreateMassTransferJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreateMassTransferJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreateMassTransferJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreateMassTransferJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreateMassTransferJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreateMassTransferJob(ctx context.Context, patchee *CreateMassTransferJob, patcher *CreateMassTransferJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreateMassTransferJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"Success" {
			patchee.Success = patcher.Success
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreateMassTransferJob executes a gorm list call
func DefaultListCreateMassTransferJob(ctx context.Context, db *gorm.DB) ([]*CreateMassTransferJob, error) {
	in := CreateMassTransferJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreateMassTransferJobORM{}, &CreateMassTransferJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreateMassTransferJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreateMassTransferJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreateMassTransferJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreateMassTransferJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreateMassTransferJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreateMassTransferJobORM) error
}

// DefaultCreateFileCheckingJob executes a basic gorm create call
func DefaultCreateFileCheckingJob(ctx context.Context, in *FileCheckingJob, db *gorm.DB) (*FileCheckingJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FileCheckingJobORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFileCheckingJob(ctx context.Context, in *FileCheckingJob, db *gorm.DB) (*FileCheckingJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FileCheckingJobORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FileCheckingJobORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FileCheckingJobORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FileCheckingJobORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFileCheckingJob(ctx context.Context, in *FileCheckingJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FileCheckingJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FileCheckingJobORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFileCheckingJobSet(ctx context.Context, in []*FileCheckingJob, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FileCheckingJobORM{})).(FileCheckingJobORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FileCheckingJobORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FileCheckingJobORM{})).(FileCheckingJobORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FileCheckingJobORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FileCheckingJob, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FileCheckingJob, *gorm.DB) error
}

// DefaultStrictUpdateFileCheckingJob clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFileCheckingJob(ctx context.Context, in *FileCheckingJob, db *gorm.DB) (*FileCheckingJob, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFileCheckingJob")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FileCheckingJobORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FileCheckingJobORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFileCheckingJob executes a basic gorm update call with patch behavior
func DefaultPatchFileCheckingJob(ctx context.Context, in *FileCheckingJob, updateMask *field_mask.FieldMask, db *gorm.DB) (*FileCheckingJob, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FileCheckingJob
	var err error
	if hook, ok := interface{}(&pbObj).(FileCheckingJobWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFileCheckingJob(ctx, &FileCheckingJob{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FileCheckingJobWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFileCheckingJob(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FileCheckingJobWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFileCheckingJob(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FileCheckingJobWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FileCheckingJobWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FileCheckingJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FileCheckingJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FileCheckingJob, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FileCheckingJob, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFileCheckingJob executes a bulk gorm update call with patch behavior
func DefaultPatchSetFileCheckingJob(ctx context.Context, objects []*FileCheckingJob, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FileCheckingJob, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FileCheckingJob, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFileCheckingJob(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFileCheckingJob patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFileCheckingJob(ctx context.Context, patchee *FileCheckingJob, patcher *FileCheckingJob, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FileCheckingJob, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRunAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"TransactionID" {
			patchee.TransactionID = patcher.TransactionID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Data" {
			patchee.Data = patcher.Data
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"Success" {
			patchee.Success = patcher.Success
			continue
		}
		if !updatedRunAt && strings.HasPrefix(f, prefix+"RunAt.") {
			if patcher.RunAt == nil {
				patchee.RunAt = nil
				continue
			}
			if patchee.RunAt == nil {
				patchee.RunAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RunAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RunAt, patchee.RunAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RunAt" {
			updatedRunAt = true
			patchee.RunAt = patcher.RunAt
			continue
		}
		if f == prefix+"Retry" {
			patchee.Retry = patcher.Retry
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"InQueue" {
			patchee.InQueue = patcher.InQueue
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFileCheckingJob executes a gorm list call
func DefaultListFileCheckingJob(ctx context.Context, db *gorm.DB) ([]*FileCheckingJob, error) {
	in := FileCheckingJob{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FileCheckingJobORM{}, &FileCheckingJob{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FileCheckingJobORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FileCheckingJobORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FileCheckingJob{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FileCheckingJobORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FileCheckingJobORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FileCheckingJobORM) error
}

// DefaultCreateUploadedFileName executes a basic gorm create call
func DefaultCreateUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UploadedFileNameORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UploadedFileNameORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UploadedFileNameORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UploadedFileNameORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UploadedFileNameORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UploadedFileNameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UploadedFileNameORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUploadedFileNameSet(ctx context.Context, in []*UploadedFileName, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UploadedFileNameORM{})).(UploadedFileNameORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UploadedFileNameORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UploadedFileNameORM{})).(UploadedFileNameORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UploadedFileNameORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UploadedFileName, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UploadedFileName, *gorm.DB) error
}

// DefaultStrictUpdateUploadedFileName clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUploadedFileName(ctx context.Context, in *UploadedFileName, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUploadedFileName")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UploadedFileNameORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UploadedFileNameORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUploadedFileName executes a basic gorm update call with patch behavior
func DefaultPatchUploadedFileName(ctx context.Context, in *UploadedFileName, updateMask *field_mask.FieldMask, db *gorm.DB) (*UploadedFileName, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UploadedFileName
	var err error
	if hook, ok := interface{}(&pbObj).(UploadedFileNameWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUploadedFileName(ctx, &UploadedFileName{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UploadedFileNameWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUploadedFileName(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UploadedFileNameWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUploadedFileName(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UploadedFileNameWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UploadedFileNameWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UploadedFileName, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUploadedFileName executes a bulk gorm update call with patch behavior
func DefaultPatchSetUploadedFileName(ctx context.Context, objects []*UploadedFileName, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UploadedFileName, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UploadedFileName, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUploadedFileName(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUploadedFileName patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUploadedFileName(ctx context.Context, patchee *UploadedFileName, patcher *UploadedFileName, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UploadedFileName, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UploadedFileName" {
			patchee.UploadedFileName = patcher.UploadedFileName
			continue
		}
		if f == prefix+"OriginalFileName" {
			patchee.OriginalFileName = patcher.OriginalFileName
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Finished" {
			patchee.Finished = patcher.Finished
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUploadedFileName executes a gorm list call
func DefaultListUploadedFileName(ctx context.Context, db *gorm.DB) ([]*UploadedFileName, error) {
	in := UploadedFileName{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UploadedFileNameORM{}, &UploadedFileName{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UploadedFileNameORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UploadedFileNameORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UploadedFileName{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UploadedFileNameORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UploadedFileNameORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UploadedFileNameORM) error
}
