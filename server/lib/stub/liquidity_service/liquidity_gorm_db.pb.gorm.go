package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type LiquiditySchemesORM struct {
	Cashflow       []*LiquidityCashflowORM `gorm:"foreignkey:liquidity_id;association_foreignkey:Id;preload:true"`
	Code           string                  `gorm:"not null"`
	CompanyGroupID uint64                  `gorm:"not null"`
	CompanyID      uint64                  `gorm:"not null"`
	CreatedAt      *time.Time
	CreatedByID    uint64
	CurrencyCode   string `gorm:"not null"`
	CurrencyID     uint64 `gorm:"not null"`
	DeletedAt      *time.Time
	DeletedByID    uint64
	Description    string     `gorm:"not null"`
	Disabled       bool       `gorm:"not null"`
	EndDate        *time.Time `gorm:"not null"`
	Id             uint64     `gorm:"primary_key;not null"`
	Priority       int32      `gorm:"not null"`
	SchemeType     string     `gorm:"not null"`
	StartDate      *time.Time `gorm:"not null"`
	UpdatedAt      *time.Time
	UpdatedByID    uint64
}

// TableName overrides the default tablename generated by GORM
func (LiquiditySchemesORM) TableName() string {
	return "liquidity_schemes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LiquiditySchemes) ToORM(ctx context.Context) (LiquiditySchemesORM, error) {
	to := LiquiditySchemesORM{}
	var err error
	if prehook, ok := interface{}(m).(LiquiditySchemesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Code = m.Code
	to.Description = m.Description
	to.CurrencyID = m.CurrencyID
	to.CurrencyCode = m.CurrencyCode
	to.CompanyID = m.CompanyID
	to.CompanyGroupID = m.CompanyGroupID
	to.SchemeType = m.SchemeType
	if m.StartDate != nil {
		t := m.StartDate.AsTime()
		to.StartDate = &t
	}
	if m.EndDate != nil {
		t := m.EndDate.AsTime()
		to.EndDate = &t
	}
	to.Priority = m.Priority
	to.Disabled = m.Disabled
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.Cashflow {
		if v != nil {
			if tempCashflow, cErr := v.ToORM(ctx); cErr == nil {
				to.Cashflow = append(to.Cashflow, &tempCashflow)
			} else {
				return to, cErr
			}
		} else {
			to.Cashflow = append(to.Cashflow, nil)
		}
	}
	if posthook, ok := interface{}(m).(LiquiditySchemesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LiquiditySchemesORM) ToPB(ctx context.Context) (LiquiditySchemes, error) {
	to := LiquiditySchemes{}
	var err error
	if prehook, ok := interface{}(m).(LiquiditySchemesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Code = m.Code
	to.Description = m.Description
	to.CurrencyID = m.CurrencyID
	to.CurrencyCode = m.CurrencyCode
	to.CompanyID = m.CompanyID
	to.CompanyGroupID = m.CompanyGroupID
	to.SchemeType = m.SchemeType
	if m.StartDate != nil {
		to.StartDate = timestamppb.New(*m.StartDate)
	}
	if m.EndDate != nil {
		to.EndDate = timestamppb.New(*m.EndDate)
	}
	to.Priority = m.Priority
	to.Disabled = m.Disabled
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.Cashflow {
		if v != nil {
			if tempCashflow, cErr := v.ToPB(ctx); cErr == nil {
				to.Cashflow = append(to.Cashflow, &tempCashflow)
			} else {
				return to, cErr
			}
		} else {
			to.Cashflow = append(to.Cashflow, nil)
		}
	}
	if posthook, ok := interface{}(m).(LiquiditySchemesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LiquiditySchemes the arg will be the target, the caller the one being converted from

// LiquiditySchemesBeforeToORM called before default ToORM code
type LiquiditySchemesWithBeforeToORM interface {
	BeforeToORM(context.Context, *LiquiditySchemesORM) error
}

// LiquiditySchemesAfterToORM called after default ToORM code
type LiquiditySchemesWithAfterToORM interface {
	AfterToORM(context.Context, *LiquiditySchemesORM) error
}

// LiquiditySchemesBeforeToPB called before default ToPB code
type LiquiditySchemesWithBeforeToPB interface {
	BeforeToPB(context.Context, *LiquiditySchemes) error
}

// LiquiditySchemesAfterToPB called after default ToPB code
type LiquiditySchemesWithAfterToPB interface {
	AfterToPB(context.Context, *LiquiditySchemes) error
}

type LiquidityCashflowORM struct {
	Beneficiaries  []*LiquidityBeneficiariesORM `gorm:"foreignkey:cashflow_id;association_foreignkey:Id;preload:true"`
	CreatedAt      *time.Time
	CreatedByID    uint64
	DeletedAt      *time.Time
	DeletedByID    uint64
	Id             uint64               `gorm:"primary_key;not null"`
	Liquidity      *LiquiditySchemesORM `gorm:"foreignkey:LiquidityId;association_foreignkey:Id"`
	LiquidityID    uint64
	LiquidityId    *uint64
	Period         string
	PeriodTime     string
	Recurring      bool
	RecurringDate  int64
	RecurringValue string
	Source         []*LiquiditySourcesORM `gorm:"foreignkey:cashflow_id;association_foreignkey:Id;preload:true"`
	TBABottomValue int64
	TBAFillDefisit bool
	TBAFillToTop   bool
	TBARoundedBase bool
	TBATopValue    int64
	TBAType        string
	TBAValue       int64
	Type           string
	UpdatedAt      *time.Time
	UpdatedByID    uint64
	liquidity_id   *uint64
}

// TableName overrides the default tablename generated by GORM
func (LiquidityCashflowORM) TableName() string {
	return "liquidity_cashflow"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LiquidityCashflow) ToORM(ctx context.Context) (LiquidityCashflowORM, error) {
	to := LiquidityCashflowORM{}
	var err error
	if prehook, ok := interface{}(m).(LiquidityCashflowWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.LiquidityID = m.LiquidityID
	if m.Liquidity != nil {
		tempLiquidity, err := m.Liquidity.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Liquidity = &tempLiquidity
	}
	to.Type = m.Type
	to.Period = m.Period
	to.PeriodTime = m.PeriodTime
	to.TBAType = m.TBAType
	to.TBAValue = m.TBAValue
	to.TBARoundedBase = m.TBARoundedBase
	to.TBATopValue = m.TBATopValue
	to.TBABottomValue = m.TBABottomValue
	to.TBAFillDefisit = m.TBAFillDefisit
	to.TBAFillToTop = m.TBAFillToTop
	to.Recurring = m.Recurring
	to.RecurringValue = m.RecurringValue
	to.RecurringDate = m.RecurringDate
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.Source {
		if v != nil {
			if tempSource, cErr := v.ToORM(ctx); cErr == nil {
				to.Source = append(to.Source, &tempSource)
			} else {
				return to, cErr
			}
		} else {
			to.Source = append(to.Source, nil)
		}
	}
	for _, v := range m.Beneficiaries {
		if v != nil {
			if tempBeneficiaries, cErr := v.ToORM(ctx); cErr == nil {
				to.Beneficiaries = append(to.Beneficiaries, &tempBeneficiaries)
			} else {
				return to, cErr
			}
		} else {
			to.Beneficiaries = append(to.Beneficiaries, nil)
		}
	}
	if posthook, ok := interface{}(m).(LiquidityCashflowWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LiquidityCashflowORM) ToPB(ctx context.Context) (LiquidityCashflow, error) {
	to := LiquidityCashflow{}
	var err error
	if prehook, ok := interface{}(m).(LiquidityCashflowWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.LiquidityID = m.LiquidityID
	if m.Liquidity != nil {
		tempLiquidity, err := m.Liquidity.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Liquidity = &tempLiquidity
	}
	to.Type = m.Type
	to.Period = m.Period
	to.PeriodTime = m.PeriodTime
	to.TBAType = m.TBAType
	to.TBAValue = m.TBAValue
	to.TBARoundedBase = m.TBARoundedBase
	to.TBATopValue = m.TBATopValue
	to.TBABottomValue = m.TBABottomValue
	to.TBAFillDefisit = m.TBAFillDefisit
	to.TBAFillToTop = m.TBAFillToTop
	to.Recurring = m.Recurring
	to.RecurringValue = m.RecurringValue
	to.RecurringDate = m.RecurringDate
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.Source {
		if v != nil {
			if tempSource, cErr := v.ToPB(ctx); cErr == nil {
				to.Source = append(to.Source, &tempSource)
			} else {
				return to, cErr
			}
		} else {
			to.Source = append(to.Source, nil)
		}
	}
	for _, v := range m.Beneficiaries {
		if v != nil {
			if tempBeneficiaries, cErr := v.ToPB(ctx); cErr == nil {
				to.Beneficiaries = append(to.Beneficiaries, &tempBeneficiaries)
			} else {
				return to, cErr
			}
		} else {
			to.Beneficiaries = append(to.Beneficiaries, nil)
		}
	}
	if posthook, ok := interface{}(m).(LiquidityCashflowWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LiquidityCashflow the arg will be the target, the caller the one being converted from

// LiquidityCashflowBeforeToORM called before default ToORM code
type LiquidityCashflowWithBeforeToORM interface {
	BeforeToORM(context.Context, *LiquidityCashflowORM) error
}

// LiquidityCashflowAfterToORM called after default ToORM code
type LiquidityCashflowWithAfterToORM interface {
	AfterToORM(context.Context, *LiquidityCashflowORM) error
}

// LiquidityCashflowBeforeToPB called before default ToPB code
type LiquidityCashflowWithBeforeToPB interface {
	BeforeToPB(context.Context, *LiquidityCashflow) error
}

// LiquidityCashflowAfterToPB called after default ToPB code
type LiquidityCashflowWithAfterToPB interface {
	AfterToPB(context.Context, *LiquidityCashflow) error
}

type LiquiditySourcesORM struct {
	AccountAlias  string
	AccountID     uint64
	AccountNumber uint64
	Caashflow     *LiquidityCashflowORM `gorm:"foreignkey:CashflowId;association_foreignkey:Id"`
	CashflowID    uint64
	CashflowId    *uint64
	CreatedAt     *time.Time
	CreatedByID   uint64
	DeletedAt     *time.Time
	DeletedByID   uint64
	Id            uint64 `gorm:"primary_key;not null"`
	UpdatedAt     *time.Time
	UpdatedByID   uint64
	cashflow_id   *uint64
}

// TableName overrides the default tablename generated by GORM
func (LiquiditySourcesORM) TableName() string {
	return "liquidity_sources"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LiquiditySources) ToORM(ctx context.Context) (LiquiditySourcesORM, error) {
	to := LiquiditySourcesORM{}
	var err error
	if prehook, ok := interface{}(m).(LiquiditySourcesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CashflowID = m.CashflowID
	if m.Caashflow != nil {
		tempCaashflow, err := m.Caashflow.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Caashflow = &tempCaashflow
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(LiquiditySourcesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LiquiditySourcesORM) ToPB(ctx context.Context) (LiquiditySources, error) {
	to := LiquiditySources{}
	var err error
	if prehook, ok := interface{}(m).(LiquiditySourcesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CashflowID = m.CashflowID
	if m.Caashflow != nil {
		tempCaashflow, err := m.Caashflow.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Caashflow = &tempCaashflow
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(LiquiditySourcesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LiquiditySources the arg will be the target, the caller the one being converted from

// LiquiditySourcesBeforeToORM called before default ToORM code
type LiquiditySourcesWithBeforeToORM interface {
	BeforeToORM(context.Context, *LiquiditySourcesORM) error
}

// LiquiditySourcesAfterToORM called after default ToORM code
type LiquiditySourcesWithAfterToORM interface {
	AfterToORM(context.Context, *LiquiditySourcesORM) error
}

// LiquiditySourcesBeforeToPB called before default ToPB code
type LiquiditySourcesWithBeforeToPB interface {
	BeforeToPB(context.Context, *LiquiditySources) error
}

// LiquiditySourcesAfterToPB called after default ToPB code
type LiquiditySourcesWithAfterToPB interface {
	AfterToPB(context.Context, *LiquiditySources) error
}

type LiquidityBeneficiariesORM struct {
	AccountAlias  string
	AccountID     uint64
	AccountNumber uint64
	Caashflow     *LiquidityCashflowORM `gorm:"foreignkey:CashflowId;association_foreignkey:Id"`
	CashflowID    uint64
	CashflowId    *uint64
	CreatedAt     *time.Time
	CreatedByID   uint64
	DeletedAt     *time.Time
	DeletedByID   uint64
	Id            uint64 `gorm:"primary_key;not null"`
	Remark        string
	TBAValue      float32
	UpdatedAt     *time.Time
	UpdatedByID   uint64
	cashflow_id   *uint64
}

// TableName overrides the default tablename generated by GORM
func (LiquidityBeneficiariesORM) TableName() string {
	return "liquidity_beneficiaries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LiquidityBeneficiaries) ToORM(ctx context.Context) (LiquidityBeneficiariesORM, error) {
	to := LiquidityBeneficiariesORM{}
	var err error
	if prehook, ok := interface{}(m).(LiquidityBeneficiariesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CashflowID = m.CashflowID
	if m.Caashflow != nil {
		tempCaashflow, err := m.Caashflow.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Caashflow = &tempCaashflow
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	to.TBAValue = m.TBAValue
	to.Remark = m.Remark
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(LiquidityBeneficiariesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LiquidityBeneficiariesORM) ToPB(ctx context.Context) (LiquidityBeneficiaries, error) {
	to := LiquidityBeneficiaries{}
	var err error
	if prehook, ok := interface{}(m).(LiquidityBeneficiariesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CashflowID = m.CashflowID
	if m.Caashflow != nil {
		tempCaashflow, err := m.Caashflow.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Caashflow = &tempCaashflow
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	to.TBAValue = m.TBAValue
	to.Remark = m.Remark
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if posthook, ok := interface{}(m).(LiquidityBeneficiariesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LiquidityBeneficiaries the arg will be the target, the caller the one being converted from

// LiquidityBeneficiariesBeforeToORM called before default ToORM code
type LiquidityBeneficiariesWithBeforeToORM interface {
	BeforeToORM(context.Context, *LiquidityBeneficiariesORM) error
}

// LiquidityBeneficiariesAfterToORM called after default ToORM code
type LiquidityBeneficiariesWithAfterToORM interface {
	AfterToORM(context.Context, *LiquidityBeneficiariesORM) error
}

// LiquidityBeneficiariesBeforeToPB called before default ToPB code
type LiquidityBeneficiariesWithBeforeToPB interface {
	BeforeToPB(context.Context, *LiquidityBeneficiaries) error
}

// LiquidityBeneficiariesAfterToPB called after default ToPB code
type LiquidityBeneficiariesWithAfterToPB interface {
	AfterToPB(context.Context, *LiquidityBeneficiaries) error
}

type LiquiditySchedulesORM struct {
	CashflowID   uint64
	Id           uint64 `gorm:"primary_key;not null"`
	LiquidityID  uint64
	ScheduleTime *time.Time
}

// TableName overrides the default tablename generated by GORM
func (LiquiditySchedulesORM) TableName() string {
	return "liquidity_schedules"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LiquiditySchedules) ToORM(ctx context.Context) (LiquiditySchedulesORM, error) {
	to := LiquiditySchedulesORM{}
	var err error
	if prehook, ok := interface{}(m).(LiquiditySchedulesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CashflowID = m.CashflowID
	to.LiquidityID = m.LiquidityID
	if m.ScheduleTime != nil {
		t := m.ScheduleTime.AsTime()
		to.ScheduleTime = &t
	}
	if posthook, ok := interface{}(m).(LiquiditySchedulesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LiquiditySchedulesORM) ToPB(ctx context.Context) (LiquiditySchedules, error) {
	to := LiquiditySchedules{}
	var err error
	if prehook, ok := interface{}(m).(LiquiditySchedulesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CashflowID = m.CashflowID
	to.LiquidityID = m.LiquidityID
	if m.ScheduleTime != nil {
		to.ScheduleTime = timestamppb.New(*m.ScheduleTime)
	}
	if posthook, ok := interface{}(m).(LiquiditySchedulesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LiquiditySchedules the arg will be the target, the caller the one being converted from

// LiquiditySchedulesBeforeToORM called before default ToORM code
type LiquiditySchedulesWithBeforeToORM interface {
	BeforeToORM(context.Context, *LiquiditySchedulesORM) error
}

// LiquiditySchedulesAfterToORM called after default ToORM code
type LiquiditySchedulesWithAfterToORM interface {
	AfterToORM(context.Context, *LiquiditySchedulesORM) error
}

// LiquiditySchedulesBeforeToPB called before default ToPB code
type LiquiditySchedulesWithBeforeToPB interface {
	BeforeToPB(context.Context, *LiquiditySchedules) error
}

// LiquiditySchedulesAfterToPB called after default ToPB code
type LiquiditySchedulesWithAfterToPB interface {
	AfterToPB(context.Context, *LiquiditySchedules) error
}

type TBAValueORM struct {
	CashFlowType string
	Id           uint64 `gorm:"primary_key;not null"`
	Mechanism    string
	Name         string
	SchemaType   string
}

// TableName overrides the default tablename generated by GORM
func (TBAValueORM) TableName() string {
	return "tba_value"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TBAValue) ToORM(ctx context.Context) (TBAValueORM, error) {
	to := TBAValueORM{}
	var err error
	if prehook, ok := interface{}(m).(TBAValueWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SchemaType = m.SchemaType
	to.CashFlowType = m.CashFlowType
	to.Name = m.Name
	to.Mechanism = m.Mechanism
	if posthook, ok := interface{}(m).(TBAValueWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TBAValueORM) ToPB(ctx context.Context) (TBAValue, error) {
	to := TBAValue{}
	var err error
	if prehook, ok := interface{}(m).(TBAValueWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SchemaType = m.SchemaType
	to.CashFlowType = m.CashFlowType
	to.Name = m.Name
	to.Mechanism = m.Mechanism
	if posthook, ok := interface{}(m).(TBAValueWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TBAValue the arg will be the target, the caller the one being converted from

// TBAValueBeforeToORM called before default ToORM code
type TBAValueWithBeforeToORM interface {
	BeforeToORM(context.Context, *TBAValueORM) error
}

// TBAValueAfterToORM called after default ToORM code
type TBAValueWithAfterToORM interface {
	AfterToORM(context.Context, *TBAValueORM) error
}

// TBAValueBeforeToPB called before default ToPB code
type TBAValueWithBeforeToPB interface {
	BeforeToPB(context.Context, *TBAValue) error
}

// TBAValueAfterToPB called after default ToPB code
type TBAValueWithAfterToPB interface {
	AfterToPB(context.Context, *TBAValue) error
}

// DefaultCreateLiquiditySchemes executes a basic gorm create call
func DefaultCreateLiquiditySchemes(ctx context.Context, in *LiquiditySchemes, db *gorm.DB) (*LiquiditySchemes, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LiquiditySchemesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLiquiditySchemes(ctx context.Context, in *LiquiditySchemes, db *gorm.DB) (*LiquiditySchemes, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LiquiditySchemesORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LiquiditySchemesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LiquiditySchemesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LiquiditySchemesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquiditySchemes(ctx context.Context, in *LiquiditySchemes, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LiquiditySchemesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LiquiditySchemesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquiditySchemesSet(ctx context.Context, in []*LiquiditySchemes, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LiquiditySchemesORM{})).(LiquiditySchemesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LiquiditySchemesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LiquiditySchemesORM{})).(LiquiditySchemesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LiquiditySchemesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LiquiditySchemes, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LiquiditySchemes, *gorm.DB) error
}

// DefaultStrictUpdateLiquiditySchemes clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLiquiditySchemes(ctx context.Context, in *LiquiditySchemes, db *gorm.DB) (*LiquiditySchemes, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLiquiditySchemes")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LiquiditySchemesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCashflow := LiquidityCashflowORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCashflow.liquidity_id = new(uint64)
	*filterCashflow.liquidity_id = ormObj.Id
	if err = db.Where(filterCashflow).Delete(LiquidityCashflowORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LiquiditySchemesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLiquiditySchemes executes a basic gorm update call with patch behavior
func DefaultPatchLiquiditySchemes(ctx context.Context, in *LiquiditySchemes, updateMask *field_mask.FieldMask, db *gorm.DB) (*LiquiditySchemes, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LiquiditySchemes
	var err error
	if hook, ok := interface{}(&pbObj).(LiquiditySchemesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLiquiditySchemes(ctx, &LiquiditySchemes{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LiquiditySchemesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLiquiditySchemes(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LiquiditySchemesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLiquiditySchemes(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LiquiditySchemesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LiquiditySchemesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LiquiditySchemes, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LiquiditySchemes, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LiquiditySchemes, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LiquiditySchemes, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLiquiditySchemes executes a bulk gorm update call with patch behavior
func DefaultPatchSetLiquiditySchemes(ctx context.Context, objects []*LiquiditySchemes, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LiquiditySchemes, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LiquiditySchemes, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLiquiditySchemes(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLiquiditySchemes patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLiquiditySchemes(ctx context.Context, patchee *LiquiditySchemes, patcher *LiquiditySchemes, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LiquiditySchemes, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartDate bool
	var updatedEndDate bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
		if f == prefix+"CurrencyCode" {
			patchee.CurrencyCode = patcher.CurrencyCode
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"CompanyGroupID" {
			patchee.CompanyGroupID = patcher.CompanyGroupID
			continue
		}
		if f == prefix+"SchemeType" {
			patchee.SchemeType = patcher.SchemeType
			continue
		}
		if !updatedStartDate && strings.HasPrefix(f, prefix+"StartDate.") {
			if patcher.StartDate == nil {
				patchee.StartDate = nil
				continue
			}
			if patchee.StartDate == nil {
				patchee.StartDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartDate, patchee.StartDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartDate" {
			updatedStartDate = true
			patchee.StartDate = patcher.StartDate
			continue
		}
		if !updatedEndDate && strings.HasPrefix(f, prefix+"EndDate.") {
			if patcher.EndDate == nil {
				patchee.EndDate = nil
				continue
			}
			if patchee.EndDate == nil {
				patchee.EndDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndDate, patchee.EndDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndDate" {
			updatedEndDate = true
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"Priority" {
			patchee.Priority = patcher.Priority
			continue
		}
		if f == prefix+"Disabled" {
			patchee.Disabled = patcher.Disabled
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"Cashflow" {
			patchee.Cashflow = patcher.Cashflow
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLiquiditySchemes executes a gorm list call
func DefaultListLiquiditySchemes(ctx context.Context, db *gorm.DB) ([]*LiquiditySchemes, error) {
	in := LiquiditySchemes{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LiquiditySchemesORM{}, &LiquiditySchemes{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LiquiditySchemesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchemesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LiquiditySchemes{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LiquiditySchemesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchemesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LiquiditySchemesORM) error
}

// DefaultCreateLiquidityCashflow executes a basic gorm create call
func DefaultCreateLiquidityCashflow(ctx context.Context, in *LiquidityCashflow, db *gorm.DB) (*LiquidityCashflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LiquidityCashflowORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLiquidityCashflow(ctx context.Context, in *LiquidityCashflow, db *gorm.DB) (*LiquidityCashflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LiquidityCashflowORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LiquidityCashflowORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LiquidityCashflowORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LiquidityCashflowORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquidityCashflow(ctx context.Context, in *LiquidityCashflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LiquidityCashflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LiquidityCashflowORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquidityCashflowSet(ctx context.Context, in []*LiquidityCashflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LiquidityCashflowORM{})).(LiquidityCashflowORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LiquidityCashflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LiquidityCashflowORM{})).(LiquidityCashflowORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LiquidityCashflowORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LiquidityCashflow, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LiquidityCashflow, *gorm.DB) error
}

// DefaultStrictUpdateLiquidityCashflow clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLiquidityCashflow(ctx context.Context, in *LiquidityCashflow, db *gorm.DB) (*LiquidityCashflow, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLiquidityCashflow")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LiquidityCashflowORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBeneficiaries := LiquidityBeneficiariesORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBeneficiaries.cashflow_id = new(uint64)
	*filterBeneficiaries.cashflow_id = ormObj.Id
	if err = db.Where(filterBeneficiaries).Delete(LiquidityBeneficiariesORM{}).Error; err != nil {
		return nil, err
	}
	filterSource := LiquiditySourcesORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSource.cashflow_id = new(uint64)
	*filterSource.cashflow_id = ormObj.Id
	if err = db.Where(filterSource).Delete(LiquiditySourcesORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LiquidityCashflowORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLiquidityCashflow executes a basic gorm update call with patch behavior
func DefaultPatchLiquidityCashflow(ctx context.Context, in *LiquidityCashflow, updateMask *field_mask.FieldMask, db *gorm.DB) (*LiquidityCashflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LiquidityCashflow
	var err error
	if hook, ok := interface{}(&pbObj).(LiquidityCashflowWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLiquidityCashflow(ctx, &LiquidityCashflow{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LiquidityCashflowWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLiquidityCashflow(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LiquidityCashflowWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLiquidityCashflow(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LiquidityCashflowWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LiquidityCashflowWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LiquidityCashflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LiquidityCashflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LiquidityCashflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LiquidityCashflow, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLiquidityCashflow executes a bulk gorm update call with patch behavior
func DefaultPatchSetLiquidityCashflow(ctx context.Context, objects []*LiquidityCashflow, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LiquidityCashflow, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LiquidityCashflow, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLiquidityCashflow(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLiquidityCashflow patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLiquidityCashflow(ctx context.Context, patchee *LiquidityCashflow, patcher *LiquidityCashflow, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LiquidityCashflow, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLiquidity bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"LiquidityID" {
			patchee.LiquidityID = patcher.LiquidityID
			continue
		}
		if !updatedLiquidity && strings.HasPrefix(f, prefix+"Liquidity.") {
			updatedLiquidity = true
			if patcher.Liquidity == nil {
				patchee.Liquidity = nil
				continue
			}
			if patchee.Liquidity == nil {
				patchee.Liquidity = &LiquiditySchemes{}
			}
			if o, err := DefaultApplyFieldMaskLiquiditySchemes(ctx, patchee.Liquidity, patcher.Liquidity, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Liquidity.", db); err != nil {
				return nil, err
			} else {
				patchee.Liquidity = o
			}
			continue
		}
		if f == prefix+"Liquidity" {
			updatedLiquidity = true
			patchee.Liquidity = patcher.Liquidity
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"PeriodTime" {
			patchee.PeriodTime = patcher.PeriodTime
			continue
		}
		if f == prefix+"TBAType" {
			patchee.TBAType = patcher.TBAType
			continue
		}
		if f == prefix+"TBAValue" {
			patchee.TBAValue = patcher.TBAValue
			continue
		}
		if f == prefix+"TBARoundedBase" {
			patchee.TBARoundedBase = patcher.TBARoundedBase
			continue
		}
		if f == prefix+"TBATopValue" {
			patchee.TBATopValue = patcher.TBATopValue
			continue
		}
		if f == prefix+"TBABottomValue" {
			patchee.TBABottomValue = patcher.TBABottomValue
			continue
		}
		if f == prefix+"TBAFillDefisit" {
			patchee.TBAFillDefisit = patcher.TBAFillDefisit
			continue
		}
		if f == prefix+"TBAFillToTop" {
			patchee.TBAFillToTop = patcher.TBAFillToTop
			continue
		}
		if f == prefix+"Recurring" {
			patchee.Recurring = patcher.Recurring
			continue
		}
		if f == prefix+"RecurringValue" {
			patchee.RecurringValue = patcher.RecurringValue
			continue
		}
		if f == prefix+"RecurringDate" {
			patchee.RecurringDate = patcher.RecurringDate
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"Source" {
			patchee.Source = patcher.Source
			continue
		}
		if f == prefix+"Beneficiaries" {
			patchee.Beneficiaries = patcher.Beneficiaries
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLiquidityCashflow executes a gorm list call
func DefaultListLiquidityCashflow(ctx context.Context, db *gorm.DB) ([]*LiquidityCashflow, error) {
	in := LiquidityCashflow{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LiquidityCashflowORM{}, &LiquidityCashflow{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LiquidityCashflowORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityCashflowORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LiquidityCashflow{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LiquidityCashflowORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityCashflowORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LiquidityCashflowORM) error
}

// DefaultCreateLiquiditySources executes a basic gorm create call
func DefaultCreateLiquiditySources(ctx context.Context, in *LiquiditySources, db *gorm.DB) (*LiquiditySources, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LiquiditySourcesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLiquiditySources(ctx context.Context, in *LiquiditySources, db *gorm.DB) (*LiquiditySources, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LiquiditySourcesORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LiquiditySourcesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LiquiditySourcesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LiquiditySourcesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquiditySources(ctx context.Context, in *LiquiditySources, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LiquiditySourcesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LiquiditySourcesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquiditySourcesSet(ctx context.Context, in []*LiquiditySources, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LiquiditySourcesORM{})).(LiquiditySourcesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LiquiditySourcesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LiquiditySourcesORM{})).(LiquiditySourcesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LiquiditySourcesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LiquiditySources, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LiquiditySources, *gorm.DB) error
}

// DefaultStrictUpdateLiquiditySources clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLiquiditySources(ctx context.Context, in *LiquiditySources, db *gorm.DB) (*LiquiditySources, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLiquiditySources")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LiquiditySourcesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LiquiditySourcesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLiquiditySources executes a basic gorm update call with patch behavior
func DefaultPatchLiquiditySources(ctx context.Context, in *LiquiditySources, updateMask *field_mask.FieldMask, db *gorm.DB) (*LiquiditySources, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LiquiditySources
	var err error
	if hook, ok := interface{}(&pbObj).(LiquiditySourcesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLiquiditySources(ctx, &LiquiditySources{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LiquiditySourcesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLiquiditySources(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LiquiditySourcesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLiquiditySources(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LiquiditySourcesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LiquiditySourcesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LiquiditySources, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LiquiditySources, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LiquiditySources, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LiquiditySources, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLiquiditySources executes a bulk gorm update call with patch behavior
func DefaultPatchSetLiquiditySources(ctx context.Context, objects []*LiquiditySources, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LiquiditySources, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LiquiditySources, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLiquiditySources(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLiquiditySources patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLiquiditySources(ctx context.Context, patchee *LiquiditySources, patcher *LiquiditySources, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LiquiditySources, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCaashflow bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CashflowID" {
			patchee.CashflowID = patcher.CashflowID
			continue
		}
		if !updatedCaashflow && strings.HasPrefix(f, prefix+"Caashflow.") {
			updatedCaashflow = true
			if patcher.Caashflow == nil {
				patchee.Caashflow = nil
				continue
			}
			if patchee.Caashflow == nil {
				patchee.Caashflow = &LiquidityCashflow{}
			}
			if o, err := DefaultApplyFieldMaskLiquidityCashflow(ctx, patchee.Caashflow, patcher.Caashflow, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Caashflow.", db); err != nil {
				return nil, err
			} else {
				patchee.Caashflow = o
			}
			continue
		}
		if f == prefix+"Caashflow" {
			updatedCaashflow = true
			patchee.Caashflow = patcher.Caashflow
			continue
		}
		if f == prefix+"AccountID" {
			patchee.AccountID = patcher.AccountID
			continue
		}
		if f == prefix+"AccountAlias" {
			patchee.AccountAlias = patcher.AccountAlias
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLiquiditySources executes a gorm list call
func DefaultListLiquiditySources(ctx context.Context, db *gorm.DB) ([]*LiquiditySources, error) {
	in := LiquiditySources{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LiquiditySourcesORM{}, &LiquiditySources{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LiquiditySourcesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySourcesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LiquiditySources{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LiquiditySourcesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySourcesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LiquiditySourcesORM) error
}

// DefaultCreateLiquidityBeneficiaries executes a basic gorm create call
func DefaultCreateLiquidityBeneficiaries(ctx context.Context, in *LiquidityBeneficiaries, db *gorm.DB) (*LiquidityBeneficiaries, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LiquidityBeneficiariesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLiquidityBeneficiaries(ctx context.Context, in *LiquidityBeneficiaries, db *gorm.DB) (*LiquidityBeneficiaries, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LiquidityBeneficiariesORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LiquidityBeneficiariesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LiquidityBeneficiariesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LiquidityBeneficiariesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquidityBeneficiaries(ctx context.Context, in *LiquidityBeneficiaries, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LiquidityBeneficiariesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LiquidityBeneficiariesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquidityBeneficiariesSet(ctx context.Context, in []*LiquidityBeneficiaries, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LiquidityBeneficiariesORM{})).(LiquidityBeneficiariesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LiquidityBeneficiariesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LiquidityBeneficiariesORM{})).(LiquidityBeneficiariesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LiquidityBeneficiariesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LiquidityBeneficiaries, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LiquidityBeneficiaries, *gorm.DB) error
}

// DefaultStrictUpdateLiquidityBeneficiaries clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLiquidityBeneficiaries(ctx context.Context, in *LiquidityBeneficiaries, db *gorm.DB) (*LiquidityBeneficiaries, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLiquidityBeneficiaries")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LiquidityBeneficiariesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LiquidityBeneficiariesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLiquidityBeneficiaries executes a basic gorm update call with patch behavior
func DefaultPatchLiquidityBeneficiaries(ctx context.Context, in *LiquidityBeneficiaries, updateMask *field_mask.FieldMask, db *gorm.DB) (*LiquidityBeneficiaries, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LiquidityBeneficiaries
	var err error
	if hook, ok := interface{}(&pbObj).(LiquidityBeneficiariesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLiquidityBeneficiaries(ctx, &LiquidityBeneficiaries{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LiquidityBeneficiariesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLiquidityBeneficiaries(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LiquidityBeneficiariesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLiquidityBeneficiaries(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LiquidityBeneficiariesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LiquidityBeneficiariesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LiquidityBeneficiaries, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LiquidityBeneficiaries, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LiquidityBeneficiaries, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LiquidityBeneficiaries, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLiquidityBeneficiaries executes a bulk gorm update call with patch behavior
func DefaultPatchSetLiquidityBeneficiaries(ctx context.Context, objects []*LiquidityBeneficiaries, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LiquidityBeneficiaries, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LiquidityBeneficiaries, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLiquidityBeneficiaries(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLiquidityBeneficiaries patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLiquidityBeneficiaries(ctx context.Context, patchee *LiquidityBeneficiaries, patcher *LiquidityBeneficiaries, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LiquidityBeneficiaries, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCaashflow bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CashflowID" {
			patchee.CashflowID = patcher.CashflowID
			continue
		}
		if !updatedCaashflow && strings.HasPrefix(f, prefix+"Caashflow.") {
			updatedCaashflow = true
			if patcher.Caashflow == nil {
				patchee.Caashflow = nil
				continue
			}
			if patchee.Caashflow == nil {
				patchee.Caashflow = &LiquidityCashflow{}
			}
			if o, err := DefaultApplyFieldMaskLiquidityCashflow(ctx, patchee.Caashflow, patcher.Caashflow, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Caashflow.", db); err != nil {
				return nil, err
			} else {
				patchee.Caashflow = o
			}
			continue
		}
		if f == prefix+"Caashflow" {
			updatedCaashflow = true
			patchee.Caashflow = patcher.Caashflow
			continue
		}
		if f == prefix+"AccountID" {
			patchee.AccountID = patcher.AccountID
			continue
		}
		if f == prefix+"AccountAlias" {
			patchee.AccountAlias = patcher.AccountAlias
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"TBAValue" {
			patchee.TBAValue = patcher.TBAValue
			continue
		}
		if f == prefix+"Remark" {
			patchee.Remark = patcher.Remark
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLiquidityBeneficiaries executes a gorm list call
func DefaultListLiquidityBeneficiaries(ctx context.Context, db *gorm.DB) ([]*LiquidityBeneficiaries, error) {
	in := LiquidityBeneficiaries{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LiquidityBeneficiariesORM{}, &LiquidityBeneficiaries{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LiquidityBeneficiariesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquidityBeneficiariesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LiquidityBeneficiaries{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LiquidityBeneficiariesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquidityBeneficiariesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LiquidityBeneficiariesORM) error
}

// DefaultCreateLiquiditySchedules executes a basic gorm create call
func DefaultCreateLiquiditySchedules(ctx context.Context, in *LiquiditySchedules, db *gorm.DB) (*LiquiditySchedules, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LiquiditySchedulesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLiquiditySchedules(ctx context.Context, in *LiquiditySchedules, db *gorm.DB) (*LiquiditySchedules, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LiquiditySchedulesORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LiquiditySchedulesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LiquiditySchedulesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LiquiditySchedulesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquiditySchedules(ctx context.Context, in *LiquiditySchedules, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LiquiditySchedulesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LiquiditySchedulesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLiquiditySchedulesSet(ctx context.Context, in []*LiquiditySchedules, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LiquiditySchedulesORM{})).(LiquiditySchedulesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LiquiditySchedulesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LiquiditySchedulesORM{})).(LiquiditySchedulesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LiquiditySchedulesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LiquiditySchedules, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LiquiditySchedules, *gorm.DB) error
}

// DefaultStrictUpdateLiquiditySchedules clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLiquiditySchedules(ctx context.Context, in *LiquiditySchedules, db *gorm.DB) (*LiquiditySchedules, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLiquiditySchedules")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LiquiditySchedulesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LiquiditySchedulesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLiquiditySchedules executes a basic gorm update call with patch behavior
func DefaultPatchLiquiditySchedules(ctx context.Context, in *LiquiditySchedules, updateMask *field_mask.FieldMask, db *gorm.DB) (*LiquiditySchedules, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LiquiditySchedules
	var err error
	if hook, ok := interface{}(&pbObj).(LiquiditySchedulesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLiquiditySchedules(ctx, &LiquiditySchedules{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LiquiditySchedulesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLiquiditySchedules(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LiquiditySchedulesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLiquiditySchedules(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LiquiditySchedulesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LiquiditySchedulesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LiquiditySchedules, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LiquiditySchedules, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LiquiditySchedules, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LiquiditySchedules, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLiquiditySchedules executes a bulk gorm update call with patch behavior
func DefaultPatchSetLiquiditySchedules(ctx context.Context, objects []*LiquiditySchedules, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LiquiditySchedules, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LiquiditySchedules, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLiquiditySchedules(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLiquiditySchedules patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLiquiditySchedules(ctx context.Context, patchee *LiquiditySchedules, patcher *LiquiditySchedules, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LiquiditySchedules, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedScheduleTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CashflowID" {
			patchee.CashflowID = patcher.CashflowID
			continue
		}
		if f == prefix+"LiquidityID" {
			patchee.LiquidityID = patcher.LiquidityID
			continue
		}
		if !updatedScheduleTime && strings.HasPrefix(f, prefix+"ScheduleTime.") {
			if patcher.ScheduleTime == nil {
				patchee.ScheduleTime = nil
				continue
			}
			if patchee.ScheduleTime == nil {
				patchee.ScheduleTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ScheduleTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ScheduleTime, patchee.ScheduleTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ScheduleTime" {
			updatedScheduleTime = true
			patchee.ScheduleTime = patcher.ScheduleTime
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLiquiditySchedules executes a gorm list call
func DefaultListLiquiditySchedules(ctx context.Context, db *gorm.DB) ([]*LiquiditySchedules, error) {
	in := LiquiditySchedules{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LiquiditySchedulesORM{}, &LiquiditySchedules{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LiquiditySchedulesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LiquiditySchedulesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LiquiditySchedules{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LiquiditySchedulesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LiquiditySchedulesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LiquiditySchedulesORM) error
}

// DefaultCreateTBAValue executes a basic gorm create call
func DefaultCreateTBAValue(ctx context.Context, in *TBAValue, db *gorm.DB) (*TBAValue, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TBAValueORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTBAValue(ctx context.Context, in *TBAValue, db *gorm.DB) (*TBAValue, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TBAValueORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TBAValueORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TBAValueORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TBAValueORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTBAValue(ctx context.Context, in *TBAValue, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TBAValueORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TBAValueORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTBAValueSet(ctx context.Context, in []*TBAValue, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TBAValueORM{})).(TBAValueORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TBAValueORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TBAValueORM{})).(TBAValueORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TBAValueORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TBAValue, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TBAValue, *gorm.DB) error
}

// DefaultStrictUpdateTBAValue clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTBAValue(ctx context.Context, in *TBAValue, db *gorm.DB) (*TBAValue, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTBAValue")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TBAValueORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TBAValueORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTBAValue executes a basic gorm update call with patch behavior
func DefaultPatchTBAValue(ctx context.Context, in *TBAValue, updateMask *field_mask.FieldMask, db *gorm.DB) (*TBAValue, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TBAValue
	var err error
	if hook, ok := interface{}(&pbObj).(TBAValueWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTBAValue(ctx, &TBAValue{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TBAValueWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTBAValue(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TBAValueWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTBAValue(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TBAValueWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TBAValueWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TBAValue, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TBAValueWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TBAValue, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TBAValueWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TBAValue, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TBAValueWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TBAValue, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTBAValue executes a bulk gorm update call with patch behavior
func DefaultPatchSetTBAValue(ctx context.Context, objects []*TBAValue, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TBAValue, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TBAValue, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTBAValue(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTBAValue patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTBAValue(ctx context.Context, patchee *TBAValue, patcher *TBAValue, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TBAValue, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"SchemaType" {
			patchee.SchemaType = patcher.SchemaType
			continue
		}
		if f == prefix+"CashFlowType" {
			patchee.CashFlowType = patcher.CashFlowType
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Mechanism" {
			patchee.Mechanism = patcher.Mechanism
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTBAValue executes a gorm list call
func DefaultListTBAValue(ctx context.Context, db *gorm.DB) ([]*TBAValue, error) {
	in := TBAValue{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TBAValueORM{}, &TBAValue{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TBAValueORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TBAValueORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TBAValue{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TBAValueORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TBAValueORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TBAValueORM) error
}
