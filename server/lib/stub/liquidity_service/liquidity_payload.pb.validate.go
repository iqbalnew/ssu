// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: liquidity_payload.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResponseMultiError, or
// nil if none found.
func (m *LoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if len(errors) > 0 {
		return LoginResponseMultiError(errors)
	}

	return nil
}

// LoginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResponseMultiError) AllErrors() []error { return m }

// LoginResponseValidationError is the validation error returned by
// LoginResponse.Validate if the designated constraints aren't met.
type LoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResponseValidationError) ErrorName() string { return "LoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e LoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResponseValidationError{}

// Validate checks the field values on HealthCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheckResponseMultiError, or nil if none found.
func (m *HealthCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return HealthCheckResponseMultiError(errors)
	}

	return nil
}

// HealthCheckResponseMultiError is an error wrapping multiple validation
// errors returned by HealthCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type HealthCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheckResponseMultiError) AllErrors() []error { return m }

// HealthCheckResponseValidationError is the validation error returned by
// HealthCheckResponse.Validate if the designated constraints aren't met.
type HealthCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheckResponseValidationError) ErrorName() string {
	return "HealthCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheckResponseValidationError{}

// Validate checks the field values on ArrayString with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArrayString) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArrayString with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArrayStringMultiError, or
// nil if none found.
func (m *ArrayString) ValidateAll() error {
	return m.validate(true)
}

func (m *ArrayString) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return ArrayStringMultiError(errors)
	}

	return nil
}

// ArrayStringMultiError is an error wrapping multiple validation errors
// returned by ArrayString.ValidateAll() if the designated constraints aren't met.
type ArrayStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArrayStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArrayStringMultiError) AllErrors() []error { return m }

// ArrayStringValidationError is the validation error returned by
// ArrayString.Validate if the designated constraints aren't met.
type ArrayStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArrayStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArrayStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArrayStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArrayStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArrayStringValidationError) ErrorName() string { return "ArrayStringValidationError" }

// Error satisfies the builtin error interface
func (e ArrayStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArrayString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArrayStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArrayStringValidationError{}

// Validate checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Empty) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmptyMultiError, or nil if none found.
func (m *Empty) ValidateAll() error {
	return m.validate(true)
}

func (m *Empty) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyMultiError(errors)
	}

	return nil
}

// EmptyMultiError is an error wrapping multiple validation errors returned by
// Empty.ValidateAll() if the designated constraints aren't met.
type EmptyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyMultiError) AllErrors() []error { return m }

// EmptyValidationError is the validation error returned by Empty.Validate if
// the designated constraints aren't met.
type EmptyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyValidationError) ErrorName() string { return "EmptyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmpty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyValidationError{}

// Validate checks the field values on PaginationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaginationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaginationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaginationResponseMultiError, or nil if none found.
func (m *PaginationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PaginationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Page

	// no validation rules for TotalRows

	// no validation rules for TotalPages

	if len(errors) > 0 {
		return PaginationResponseMultiError(errors)
	}

	return nil
}

// PaginationResponseMultiError is an error wrapping multiple validation errors
// returned by PaginationResponse.ValidateAll() if the designated constraints
// aren't met.
type PaginationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaginationResponseMultiError) AllErrors() []error { return m }

// PaginationResponseValidationError is the validation error returned by
// PaginationResponse.Validate if the designated constraints aren't met.
type PaginationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaginationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaginationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaginationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaginationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaginationResponseValidationError) ErrorName() string {
	return "PaginationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PaginationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaginationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaginationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaginationResponseValidationError{}

// Validate checks the field values on Sort with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Sort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sort with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SortMultiError, or nil if none found.
func (m *Sort) ValidateAll() error {
	return m.validate(true)
}

func (m *Sort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Column

	// no validation rules for Direction

	if len(errors) > 0 {
		return SortMultiError(errors)
	}

	return nil
}

// SortMultiError is an error wrapping multiple validation errors returned by
// Sort.ValidateAll() if the designated constraints aren't met.
type SortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SortMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SortMultiError) AllErrors() []error { return m }

// SortValidationError is the validation error returned by Sort.Validate if the
// designated constraints aren't met.
type SortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SortValidationError) ErrorName() string { return "SortValidationError" }

// Error satisfies the builtin error interface
func (e SortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SortValidationError{}

// Validate checks the field values on ErrorBodyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ErrorBodyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorBodyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErrorBodyResponseMultiError, or nil if none found.
func (m *ErrorBodyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorBodyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return ErrorBodyResponseMultiError(errors)
	}

	return nil
}

// ErrorBodyResponseMultiError is an error wrapping multiple validation errors
// returned by ErrorBodyResponse.ValidateAll() if the designated constraints
// aren't met.
type ErrorBodyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorBodyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorBodyResponseMultiError) AllErrors() []error { return m }

// ErrorBodyResponseValidationError is the validation error returned by
// ErrorBodyResponse.Validate if the designated constraints aren't met.
type ErrorBodyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorBodyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorBodyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorBodyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorBodyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorBodyResponseValidationError) ErrorName() string {
	return "ErrorBodyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ErrorBodyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorBodyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorBodyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorBodyResponseValidationError{}

// Validate checks the field values on ListLiquidityFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLiquidityFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLiquidityFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLiquidityFilterMultiError, or nil if none found.
func (m *ListLiquidityFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLiquidityFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Company

	// no validation rules for CreateBy

	// no validation rules for ReviewedBy

	// no validation rules for SchemeType

	// no validation rules for FlowType

	// no validation rules for Period

	// no validation rules for StartDate

	// no validation rules for EndDate

	// no validation rules for StartDateModified

	// no validation rules for EndDateModified

	// no validation rules for RunningStatus

	if len(errors) > 0 {
		return ListLiquidityFilterMultiError(errors)
	}

	return nil
}

// ListLiquidityFilterMultiError is an error wrapping multiple validation
// errors returned by ListLiquidityFilter.ValidateAll() if the designated
// constraints aren't met.
type ListLiquidityFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLiquidityFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLiquidityFilterMultiError) AllErrors() []error { return m }

// ListLiquidityFilterValidationError is the validation error returned by
// ListLiquidityFilter.Validate if the designated constraints aren't met.
type ListLiquidityFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLiquidityFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLiquidityFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLiquidityFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLiquidityFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLiquidityFilterValidationError) ErrorName() string {
	return "ListLiquidityFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListLiquidityFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLiquidityFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLiquidityFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLiquidityFilterValidationError{}

// Validate checks the field values on ListTaskLiquidityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTaskLiquidityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskLiquidityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskLiquidityRequestMultiError, or nil if none found.
func (m *ListTaskLiquidityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskLiquidityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Step

	// no validation rules for Limit

	// no validation rules for Page

	// no validation rules for Sort

	// no validation rules for Dir

	// no validation rules for Filter

	// no validation rules for Query

	if len(errors) > 0 {
		return ListTaskLiquidityRequestMultiError(errors)
	}

	return nil
}

// ListTaskLiquidityRequestMultiError is an error wrapping multiple validation
// errors returned by ListTaskLiquidityRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTaskLiquidityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskLiquidityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskLiquidityRequestMultiError) AllErrors() []error { return m }

// ListTaskLiquidityRequestValidationError is the validation error returned by
// ListTaskLiquidityRequest.Validate if the designated constraints aren't met.
type ListTaskLiquidityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskLiquidityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskLiquidityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskLiquidityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskLiquidityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskLiquidityRequestValidationError) ErrorName() string {
	return "ListTaskLiquidityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTaskLiquidityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskLiquidityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskLiquidityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskLiquidityRequestValidationError{}

// Validate checks the field values on DownloadListTaskLiquidityRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DownloadListTaskLiquidityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadListTaskLiquidityRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadListTaskLiquidityRequestMultiError, or nil if none found.
func (m *DownloadListTaskLiquidityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadListTaskLiquidityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Step

	// no validation rules for Limit

	// no validation rules for Page

	// no validation rules for Sort

	// no validation rules for Dir

	// no validation rules for Filter

	// no validation rules for Query

	// no validation rules for FileFormat

	if len(errors) > 0 {
		return DownloadListTaskLiquidityRequestMultiError(errors)
	}

	return nil
}

// DownloadListTaskLiquidityRequestMultiError is an error wrapping multiple
// validation errors returned by
// DownloadListTaskLiquidityRequest.ValidateAll() if the designated
// constraints aren't met.
type DownloadListTaskLiquidityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadListTaskLiquidityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadListTaskLiquidityRequestMultiError) AllErrors() []error { return m }

// DownloadListTaskLiquidityRequestValidationError is the validation error
// returned by DownloadListTaskLiquidityRequest.Validate if the designated
// constraints aren't met.
type DownloadListTaskLiquidityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadListTaskLiquidityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadListTaskLiquidityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadListTaskLiquidityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadListTaskLiquidityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadListTaskLiquidityRequestValidationError) ErrorName() string {
	return "DownloadListTaskLiquidityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadListTaskLiquidityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadListTaskLiquidityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadListTaskLiquidityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadListTaskLiquidityRequestValidationError{}

// Validate checks the field values on TaskLiquidityData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskLiquidityData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskLiquidityData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskLiquidityDataMultiError, or nil if none found.
func (m *TaskLiquidityData) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskLiquidityData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskLiquidityDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskLiquidityDataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskLiquidityDataValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskLiquidityDataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskLiquidityDataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskLiquidityDataValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskLiquidityDataValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskLiquidityDataValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskLiquidityDataValidationError{
				field:  "Workflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskLiquidityDataMultiError(errors)
	}

	return nil
}

// TaskLiquidityDataMultiError is an error wrapping multiple validation errors
// returned by TaskLiquidityData.ValidateAll() if the designated constraints
// aren't met.
type TaskLiquidityDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskLiquidityDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskLiquidityDataMultiError) AllErrors() []error { return m }

// TaskLiquidityDataValidationError is the validation error returned by
// TaskLiquidityData.Validate if the designated constraints aren't met.
type TaskLiquidityDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskLiquidityDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskLiquidityDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskLiquidityDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskLiquidityDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskLiquidityDataValidationError) ErrorName() string {
	return "TaskLiquidityDataValidationError"
}

// Error satisfies the builtin error interface
func (e TaskLiquidityDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskLiquidityData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskLiquidityDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskLiquidityDataValidationError{}

// Validate checks the field values on ListLiquidityTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLiquidityTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLiquidityTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLiquidityTaskResponseMultiError, or nil if none found.
func (m *ListLiquidityTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLiquidityTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListLiquidityTaskResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListLiquidityTaskResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListLiquidityTaskResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListLiquidityTaskResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListLiquidityTaskResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListLiquidityTaskResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListLiquidityTaskResponseMultiError(errors)
	}

	return nil
}

// ListLiquidityTaskResponseMultiError is an error wrapping multiple validation
// errors returned by ListLiquidityTaskResponse.ValidateAll() if the
// designated constraints aren't met.
type ListLiquidityTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLiquidityTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLiquidityTaskResponseMultiError) AllErrors() []error { return m }

// ListLiquidityTaskResponseValidationError is the validation error returned by
// ListLiquidityTaskResponse.Validate if the designated constraints aren't met.
type ListLiquidityTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLiquidityTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLiquidityTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLiquidityTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLiquidityTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLiquidityTaskResponseValidationError) ErrorName() string {
	return "ListLiquidityTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLiquidityTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLiquidityTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLiquidityTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLiquidityTaskResponseValidationError{}

// Validate checks the field values on ListTaskLiquidityRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTaskLiquidityRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskLiquidityRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskLiquidityResMultiError, or nil if none found.
func (m *ListTaskLiquidityRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskLiquidityRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for LiquidityID

	if all {
		switch v := interface{}(m.GetCompanyGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "CompanyGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "CompanyGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompanyGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTaskLiquidityResValidationError{
				field:  "CompanyGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompany()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "Company",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "Company",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompany()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTaskLiquidityResValidationError{
				field:  "Company",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTaskLiquidityResValidationError{
				field:  "Currency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SchemeType

	// no validation rules for Description

	for idx, item := range m.GetCashflow() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskLiquidityResValidationError{
						field:  fmt.Sprintf("Cashflow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskLiquidityResValidationError{
						field:  fmt.Sprintf("Cashflow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskLiquidityResValidationError{
					field:  fmt.Sprintf("Cashflow[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for StartDate

	// no validation rules for EndDate

	// no validation rules for Disabled

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTaskLiquidityResValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTaskLiquidityResValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListTaskLiquidityResMultiError(errors)
	}

	return nil
}

// ListTaskLiquidityResMultiError is an error wrapping multiple validation
// errors returned by ListTaskLiquidityRes.ValidateAll() if the designated
// constraints aren't met.
type ListTaskLiquidityResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskLiquidityResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskLiquidityResMultiError) AllErrors() []error { return m }

// ListTaskLiquidityResValidationError is the validation error returned by
// ListTaskLiquidityRes.Validate if the designated constraints aren't met.
type ListTaskLiquidityResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskLiquidityResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskLiquidityResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskLiquidityResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskLiquidityResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskLiquidityResValidationError) ErrorName() string {
	return "ListTaskLiquidityResValidationError"
}

// Error satisfies the builtin error interface
func (e ListTaskLiquidityResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskLiquidityRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskLiquidityResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskLiquidityResValidationError{}

// Validate checks the field values on CompanyGroupListTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompanyGroupListTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyGroupListTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompanyGroupListTaskMultiError, or nil if none found.
func (m *CompanyGroupListTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyGroupListTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyGroupID

	// no validation rules for Name

	if len(errors) > 0 {
		return CompanyGroupListTaskMultiError(errors)
	}

	return nil
}

// CompanyGroupListTaskMultiError is an error wrapping multiple validation
// errors returned by CompanyGroupListTask.ValidateAll() if the designated
// constraints aren't met.
type CompanyGroupListTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyGroupListTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyGroupListTaskMultiError) AllErrors() []error { return m }

// CompanyGroupListTaskValidationError is the validation error returned by
// CompanyGroupListTask.Validate if the designated constraints aren't met.
type CompanyGroupListTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyGroupListTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyGroupListTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyGroupListTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyGroupListTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyGroupListTaskValidationError) ErrorName() string {
	return "CompanyGroupListTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CompanyGroupListTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyGroupListTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyGroupListTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyGroupListTaskValidationError{}

// Validate checks the field values on CompanyListTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompanyListTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyListTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompanyListTaskMultiError, or nil if none found.
func (m *CompanyListTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyListTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyID

	// no validation rules for Name

	if len(errors) > 0 {
		return CompanyListTaskMultiError(errors)
	}

	return nil
}

// CompanyListTaskMultiError is an error wrapping multiple validation errors
// returned by CompanyListTask.ValidateAll() if the designated constraints
// aren't met.
type CompanyListTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyListTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyListTaskMultiError) AllErrors() []error { return m }

// CompanyListTaskValidationError is the validation error returned by
// CompanyListTask.Validate if the designated constraints aren't met.
type CompanyListTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyListTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyListTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyListTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyListTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyListTaskValidationError) ErrorName() string { return "CompanyListTaskValidationError" }

// Error satisfies the builtin error interface
func (e CompanyListTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyListTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyListTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyListTaskValidationError{}

// Validate checks the field values on CurrencyListTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CurrencyListTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CurrencyListTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CurrencyListTaskMultiError, or nil if none found.
func (m *CurrencyListTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CurrencyListTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Name

	// no validation rules for CurrencyID

	if len(errors) > 0 {
		return CurrencyListTaskMultiError(errors)
	}

	return nil
}

// CurrencyListTaskMultiError is an error wrapping multiple validation errors
// returned by CurrencyListTask.ValidateAll() if the designated constraints
// aren't met.
type CurrencyListTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyListTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyListTaskMultiError) AllErrors() []error { return m }

// CurrencyListTaskValidationError is the validation error returned by
// CurrencyListTask.Validate if the designated constraints aren't met.
type CurrencyListTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyListTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyListTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyListTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyListTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyListTaskValidationError) ErrorName() string { return "CurrencyListTaskValidationError" }

// Error satisfies the builtin error interface
func (e CurrencyListTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrencyListTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyListTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyListTaskValidationError{}

// Validate checks the field values on CashflowsListTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CashflowsListTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CashflowsListTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CashflowsListTaskMultiError, or nil if none found.
func (m *CashflowsListTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CashflowsListTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CashflowID

	// no validation rules for CashflowType

	// no validation rules for Period

	// no validation rules for PeriodTime

	// no validation rules for TBAType

	// no validation rules for TBAValue

	// no validation rules for TBARoundedBase

	// no validation rules for TBATopValue

	// no validation rules for TBABottomValue

	// no validation rules for TBAFillDefisit

	// no validation rules for TBAFillToTop

	// no validation rules for Recurring

	// no validation rules for RecurringValue

	// no validation rules for RecurringDate

	for idx, item := range m.GetSource() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashflowsListTaskValidationError{
						field:  fmt.Sprintf("Source[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashflowsListTaskValidationError{
						field:  fmt.Sprintf("Source[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashflowsListTaskValidationError{
					field:  fmt.Sprintf("Source[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBeneficiary() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashflowsListTaskValidationError{
						field:  fmt.Sprintf("Beneficiary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashflowsListTaskValidationError{
						field:  fmt.Sprintf("Beneficiary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashflowsListTaskValidationError{
					field:  fmt.Sprintf("Beneficiary[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CashflowsListTaskMultiError(errors)
	}

	return nil
}

// CashflowsListTaskMultiError is an error wrapping multiple validation errors
// returned by CashflowsListTask.ValidateAll() if the designated constraints
// aren't met.
type CashflowsListTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CashflowsListTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CashflowsListTaskMultiError) AllErrors() []error { return m }

// CashflowsListTaskValidationError is the validation error returned by
// CashflowsListTask.Validate if the designated constraints aren't met.
type CashflowsListTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CashflowsListTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CashflowsListTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CashflowsListTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CashflowsListTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CashflowsListTaskValidationError) ErrorName() string {
	return "CashflowsListTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CashflowsListTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCashflowsListTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CashflowsListTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CashflowsListTaskValidationError{}

// Validate checks the field values on DetailLiquidityTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DetailLiquidityTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetailLiquidityTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DetailLiquidityTaskRequestMultiError, or nil if none found.
func (m *DetailLiquidityTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DetailLiquidityTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskID

	if len(errors) > 0 {
		return DetailLiquidityTaskRequestMultiError(errors)
	}

	return nil
}

// DetailLiquidityTaskRequestMultiError is an error wrapping multiple
// validation errors returned by DetailLiquidityTaskRequest.ValidateAll() if
// the designated constraints aren't met.
type DetailLiquidityTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetailLiquidityTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetailLiquidityTaskRequestMultiError) AllErrors() []error { return m }

// DetailLiquidityTaskRequestValidationError is the validation error returned
// by DetailLiquidityTaskRequest.Validate if the designated constraints aren't met.
type DetailLiquidityTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetailLiquidityTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetailLiquidityTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetailLiquidityTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetailLiquidityTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetailLiquidityTaskRequestValidationError) ErrorName() string {
	return "DetailLiquidityTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DetailLiquidityTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetailLiquidityTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetailLiquidityTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetailLiquidityTaskRequestValidationError{}

// Validate checks the field values on DetailLiquidityTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DetailLiquidityTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetailLiquidityTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DetailLiquidityTaskResponseMultiError, or nil if none found.
func (m *DetailLiquidityTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DetailLiquidityTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DetailLiquidityTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DetailLiquidityTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DetailLiquidityTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DetailLiquidityTaskResponseMultiError(errors)
	}

	return nil
}

// DetailLiquidityTaskResponseMultiError is an error wrapping multiple
// validation errors returned by DetailLiquidityTaskResponse.ValidateAll() if
// the designated constraints aren't met.
type DetailLiquidityTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetailLiquidityTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetailLiquidityTaskResponseMultiError) AllErrors() []error { return m }

// DetailLiquidityTaskResponseValidationError is the validation error returned
// by DetailLiquidityTaskResponse.Validate if the designated constraints
// aren't met.
type DetailLiquidityTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetailLiquidityTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetailLiquidityTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetailLiquidityTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetailLiquidityTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetailLiquidityTaskResponseValidationError) ErrorName() string {
	return "DetailLiquidityTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DetailLiquidityTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetailLiquidityTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetailLiquidityTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetailLiquidityTaskResponseValidationError{}

// Validate checks the field values on DetailTaskLiquidityRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DetailTaskLiquidityRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetailTaskLiquidityRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DetailTaskLiquidityResMultiError, or nil if none found.
func (m *DetailTaskLiquidityRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DetailTaskLiquidityRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for LiquidityID

	if all {
		switch v := interface{}(m.GetCompanyGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "CompanyGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "CompanyGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompanyGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DetailTaskLiquidityResValidationError{
				field:  "CompanyGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompany()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "Company",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "Company",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompany()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DetailTaskLiquidityResValidationError{
				field:  "Company",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DetailTaskLiquidityResValidationError{
				field:  "Currency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SchemeType

	// no validation rules for Description

	for idx, item := range m.GetCashflow() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DetailTaskLiquidityResValidationError{
						field:  fmt.Sprintf("Cashflow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DetailTaskLiquidityResValidationError{
						field:  fmt.Sprintf("Cashflow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DetailTaskLiquidityResValidationError{
					field:  fmt.Sprintf("Cashflow[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for StartDate

	// no validation rules for EndDate

	// no validation rules for Disabled

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DetailTaskLiquidityResValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DetailTaskLiquidityResValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DetailTaskLiquidityResMultiError(errors)
	}

	return nil
}

// DetailTaskLiquidityResMultiError is an error wrapping multiple validation
// errors returned by DetailTaskLiquidityRes.ValidateAll() if the designated
// constraints aren't met.
type DetailTaskLiquidityResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetailTaskLiquidityResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetailTaskLiquidityResMultiError) AllErrors() []error { return m }

// DetailTaskLiquidityResValidationError is the validation error returned by
// DetailTaskLiquidityRes.Validate if the designated constraints aren't met.
type DetailTaskLiquidityResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetailTaskLiquidityResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetailTaskLiquidityResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetailTaskLiquidityResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetailTaskLiquidityResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetailTaskLiquidityResValidationError) ErrorName() string {
	return "DetailTaskLiquidityResValidationError"
}

// Error satisfies the builtin error interface
func (e DetailTaskLiquidityResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetailTaskLiquidityRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetailTaskLiquidityResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetailTaskLiquidityResValidationError{}

// Validate checks the field values on CompanyGroupDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompanyGroupDetailTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyGroupDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompanyGroupDetailTaskMultiError, or nil if none found.
func (m *CompanyGroupDetailTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyGroupDetailTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyGroupID

	// no validation rules for Name

	if len(errors) > 0 {
		return CompanyGroupDetailTaskMultiError(errors)
	}

	return nil
}

// CompanyGroupDetailTaskMultiError is an error wrapping multiple validation
// errors returned by CompanyGroupDetailTask.ValidateAll() if the designated
// constraints aren't met.
type CompanyGroupDetailTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyGroupDetailTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyGroupDetailTaskMultiError) AllErrors() []error { return m }

// CompanyGroupDetailTaskValidationError is the validation error returned by
// CompanyGroupDetailTask.Validate if the designated constraints aren't met.
type CompanyGroupDetailTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyGroupDetailTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyGroupDetailTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyGroupDetailTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyGroupDetailTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyGroupDetailTaskValidationError) ErrorName() string {
	return "CompanyGroupDetailTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CompanyGroupDetailTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyGroupDetailTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyGroupDetailTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyGroupDetailTaskValidationError{}

// Validate checks the field values on CompanyDetailTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompanyDetailTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompanyDetailTaskMultiError, or nil if none found.
func (m *CompanyDetailTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyDetailTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyID

	// no validation rules for Name

	if len(errors) > 0 {
		return CompanyDetailTaskMultiError(errors)
	}

	return nil
}

// CompanyDetailTaskMultiError is an error wrapping multiple validation errors
// returned by CompanyDetailTask.ValidateAll() if the designated constraints
// aren't met.
type CompanyDetailTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyDetailTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyDetailTaskMultiError) AllErrors() []error { return m }

// CompanyDetailTaskValidationError is the validation error returned by
// CompanyDetailTask.Validate if the designated constraints aren't met.
type CompanyDetailTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyDetailTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyDetailTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyDetailTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyDetailTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyDetailTaskValidationError) ErrorName() string {
	return "CompanyDetailTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CompanyDetailTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyDetailTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyDetailTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyDetailTaskValidationError{}

// Validate checks the field values on CurrencyDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CurrencyDetailTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CurrencyDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CurrencyDetailTaskMultiError, or nil if none found.
func (m *CurrencyDetailTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CurrencyDetailTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrencyID

	// no validation rules for Name

	if len(errors) > 0 {
		return CurrencyDetailTaskMultiError(errors)
	}

	return nil
}

// CurrencyDetailTaskMultiError is an error wrapping multiple validation errors
// returned by CurrencyDetailTask.ValidateAll() if the designated constraints
// aren't met.
type CurrencyDetailTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyDetailTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyDetailTaskMultiError) AllErrors() []error { return m }

// CurrencyDetailTaskValidationError is the validation error returned by
// CurrencyDetailTask.Validate if the designated constraints aren't met.
type CurrencyDetailTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyDetailTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyDetailTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyDetailTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyDetailTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyDetailTaskValidationError) ErrorName() string {
	return "CurrencyDetailTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CurrencyDetailTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrencyDetailTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyDetailTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyDetailTaskValidationError{}

// Validate checks the field values on CashflowsDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CashflowsDetailTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CashflowsDetailTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CashflowsDetailTaskMultiError, or nil if none found.
func (m *CashflowsDetailTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CashflowsDetailTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CashflowID

	// no validation rules for CashflowType

	// no validation rules for Period

	// no validation rules for PeriodTime

	// no validation rules for TBAType

	// no validation rules for TBAValue

	// no validation rules for TBARoundedBase

	// no validation rules for TBATopValue

	// no validation rules for TBABottomValue

	// no validation rules for TBAFillDefisit

	// no validation rules for TBAFillToTop

	// no validation rules for Recurring

	// no validation rules for RecurringValue

	// no validation rules for RecurringDate

	for idx, item := range m.GetSource() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashflowsDetailTaskValidationError{
						field:  fmt.Sprintf("Source[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashflowsDetailTaskValidationError{
						field:  fmt.Sprintf("Source[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashflowsDetailTaskValidationError{
					field:  fmt.Sprintf("Source[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBeneficiary() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashflowsDetailTaskValidationError{
						field:  fmt.Sprintf("Beneficiary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashflowsDetailTaskValidationError{
						field:  fmt.Sprintf("Beneficiary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashflowsDetailTaskValidationError{
					field:  fmt.Sprintf("Beneficiary[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CashflowsDetailTaskMultiError(errors)
	}

	return nil
}

// CashflowsDetailTaskMultiError is an error wrapping multiple validation
// errors returned by CashflowsDetailTask.ValidateAll() if the designated
// constraints aren't met.
type CashflowsDetailTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CashflowsDetailTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CashflowsDetailTaskMultiError) AllErrors() []error { return m }

// CashflowsDetailTaskValidationError is the validation error returned by
// CashflowsDetailTask.Validate if the designated constraints aren't met.
type CashflowsDetailTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CashflowsDetailTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CashflowsDetailTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CashflowsDetailTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CashflowsDetailTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CashflowsDetailTaskValidationError) ErrorName() string {
	return "CashflowsDetailTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CashflowsDetailTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCashflowsDetailTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CashflowsDetailTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CashflowsDetailTaskValidationError{}

// Validate checks the field values on CreateLiquidityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLiquidityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLiquidityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLiquidityRequestMultiError, or nil if none found.
func (m *CreateLiquidityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLiquidityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLiquidityRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLiquidityRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLiquidityRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TaskID

	if len(errors) > 0 {
		return CreateLiquidityRequestMultiError(errors)
	}

	return nil
}

// CreateLiquidityRequestMultiError is an error wrapping multiple validation
// errors returned by CreateLiquidityRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateLiquidityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLiquidityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLiquidityRequestMultiError) AllErrors() []error { return m }

// CreateLiquidityRequestValidationError is the validation error returned by
// CreateLiquidityRequest.Validate if the designated constraints aren't met.
type CreateLiquidityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLiquidityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLiquidityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLiquidityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLiquidityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLiquidityRequestValidationError) ErrorName() string {
	return "CreateLiquidityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLiquidityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLiquidityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLiquidityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLiquidityRequestValidationError{}

// Validate checks the field values on CreateTaskLiquidityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaskLiquidityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaskLiquidityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaskLiquidityRequestMultiError, or nil if none found.
func (m *CreateTaskLiquidityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaskLiquidityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TaskID

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetCompany()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaskLiquidityRequestValidationError{
					field:  "Company",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaskLiquidityRequestValidationError{
					field:  "Company",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompany()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaskLiquidityRequestValidationError{
				field:  "Company",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompanyGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaskLiquidityRequestValidationError{
					field:  "CompanyGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaskLiquidityRequestValidationError{
					field:  "CompanyGroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompanyGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaskLiquidityRequestValidationError{
				field:  "CompanyGroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTaskLiquidityRequestValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTaskLiquidityRequestValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTaskLiquidityRequestValidationError{
				field:  "Currency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetCompanyGroupID() <= 0 {
		err := CreateTaskLiquidityRequestValidationError{
			field:  "CompanyGroupID",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetCompanyID() <= 0 {
		err := CreateTaskLiquidityRequestValidationError{
			field:  "CompanyID",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CurrencyID

	if _, ok := _CreateTaskLiquidityRequest_SchemeType_InLookup[m.GetSchemeType()]; !ok {
		err := CreateTaskLiquidityRequestValidationError{
			field:  "SchemeType",
			reason: "value must be in list [one-time swepback]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	for idx, item := range m.GetCashflow() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTaskLiquidityRequestValidationError{
						field:  fmt.Sprintf("Cashflow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTaskLiquidityRequestValidationError{
						field:  fmt.Sprintf("Cashflow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTaskLiquidityRequestValidationError{
					field:  fmt.Sprintf("Cashflow[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if !_CreateTaskLiquidityRequest_StartDate_Pattern.MatchString(m.GetStartDate()) {
		err := CreateTaskLiquidityRequestValidationError{
			field:  "StartDate",
			reason: "value does not match regex pattern \"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateTaskLiquidityRequest_EndDate_Pattern.MatchString(m.GetEndDate()) {
		err := CreateTaskLiquidityRequestValidationError{
			field:  "EndDate",
			reason: "value does not match regex pattern \"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	for idx, item := range m.GetPriorityUpdates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTaskLiquidityRequestValidationError{
						field:  fmt.Sprintf("PriorityUpdates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTaskLiquidityRequestValidationError{
						field:  fmt.Sprintf("PriorityUpdates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTaskLiquidityRequestValidationError{
					field:  fmt.Sprintf("PriorityUpdates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsDraft

	// no validation rules for IsActive

	if len(errors) > 0 {
		return CreateTaskLiquidityRequestMultiError(errors)
	}

	return nil
}

// CreateTaskLiquidityRequestMultiError is an error wrapping multiple
// validation errors returned by CreateTaskLiquidityRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateTaskLiquidityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaskLiquidityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaskLiquidityRequestMultiError) AllErrors() []error { return m }

// CreateTaskLiquidityRequestValidationError is the validation error returned
// by CreateTaskLiquidityRequest.Validate if the designated constraints aren't met.
type CreateTaskLiquidityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaskLiquidityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaskLiquidityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaskLiquidityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaskLiquidityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaskLiquidityRequestValidationError) ErrorName() string {
	return "CreateTaskLiquidityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaskLiquidityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaskLiquidityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaskLiquidityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaskLiquidityRequestValidationError{}

var _CreateTaskLiquidityRequest_SchemeType_InLookup = map[string]struct{}{
	"one-time": {},
	"swepback": {},
}

var _CreateTaskLiquidityRequest_StartDate_Pattern = regexp.MustCompile("^\\d{4}-\\d{2}-\\d{2}$")

var _CreateTaskLiquidityRequest_EndDate_Pattern = regexp.MustCompile("^\\d{4}-\\d{2}-\\d{2}$")

// Validate checks the field values on LiquiditySourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LiquiditySourceReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LiquiditySourceReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LiquiditySourceReqMultiError, or nil if none found.
func (m *LiquiditySourceReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LiquiditySourceReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountID() <= 0 {
		err := LiquiditySourceReqValidationError{
			field:  "AccountID",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountAlias()) < 1 {
		err := LiquiditySourceReqValidationError{
			field:  "AccountAlias",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountNumber

	// no validation rules for TBAFillDefisit

	// no validation rules for TBAFillToTop

	if len(errors) > 0 {
		return LiquiditySourceReqMultiError(errors)
	}

	return nil
}

// LiquiditySourceReqMultiError is an error wrapping multiple validation errors
// returned by LiquiditySourceReq.ValidateAll() if the designated constraints
// aren't met.
type LiquiditySourceReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LiquiditySourceReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LiquiditySourceReqMultiError) AllErrors() []error { return m }

// LiquiditySourceReqValidationError is the validation error returned by
// LiquiditySourceReq.Validate if the designated constraints aren't met.
type LiquiditySourceReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiquiditySourceReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiquiditySourceReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiquiditySourceReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiquiditySourceReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiquiditySourceReqValidationError) ErrorName() string {
	return "LiquiditySourceReqValidationError"
}

// Error satisfies the builtin error interface
func (e LiquiditySourceReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiquiditySourceReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiquiditySourceReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiquiditySourceReqValidationError{}

// Validate checks the field values on LiquidityBeneficiaryReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LiquidityBeneficiaryReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LiquidityBeneficiaryReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LiquidityBeneficiaryReqMultiError, or nil if none found.
func (m *LiquidityBeneficiaryReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LiquidityBeneficiaryReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountID() <= 0 {
		err := LiquidityBeneficiaryReqValidationError{
			field:  "AccountID",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAccountAlias()) < 1 {
		err := LiquidityBeneficiaryReqValidationError{
			field:  "AccountAlias",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccountNumber

	// no validation rules for TBAValue

	// no validation rules for Remark

	// no validation rules for TBAFillDefisit

	// no validation rules for TBAFillToTop

	if len(errors) > 0 {
		return LiquidityBeneficiaryReqMultiError(errors)
	}

	return nil
}

// LiquidityBeneficiaryReqMultiError is an error wrapping multiple validation
// errors returned by LiquidityBeneficiaryReq.ValidateAll() if the designated
// constraints aren't met.
type LiquidityBeneficiaryReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LiquidityBeneficiaryReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LiquidityBeneficiaryReqMultiError) AllErrors() []error { return m }

// LiquidityBeneficiaryReqValidationError is the validation error returned by
// LiquidityBeneficiaryReq.Validate if the designated constraints aren't met.
type LiquidityBeneficiaryReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiquidityBeneficiaryReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiquidityBeneficiaryReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiquidityBeneficiaryReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiquidityBeneficiaryReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiquidityBeneficiaryReqValidationError) ErrorName() string {
	return "LiquidityBeneficiaryReqValidationError"
}

// Error satisfies the builtin error interface
func (e LiquidityBeneficiaryReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiquidityBeneficiaryReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiquidityBeneficiaryReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiquidityBeneficiaryReqValidationError{}

// Validate checks the field values on LiquiditySourceRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LiquiditySourceRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LiquiditySourceRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LiquiditySourceResMultiError, or nil if none found.
func (m *LiquiditySourceRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LiquiditySourceRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountID

	// no validation rules for AccountAlias

	// no validation rules for AccountNumber

	if len(errors) > 0 {
		return LiquiditySourceResMultiError(errors)
	}

	return nil
}

// LiquiditySourceResMultiError is an error wrapping multiple validation errors
// returned by LiquiditySourceRes.ValidateAll() if the designated constraints
// aren't met.
type LiquiditySourceResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LiquiditySourceResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LiquiditySourceResMultiError) AllErrors() []error { return m }

// LiquiditySourceResValidationError is the validation error returned by
// LiquiditySourceRes.Validate if the designated constraints aren't met.
type LiquiditySourceResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiquiditySourceResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiquiditySourceResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiquiditySourceResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiquiditySourceResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiquiditySourceResValidationError) ErrorName() string {
	return "LiquiditySourceResValidationError"
}

// Error satisfies the builtin error interface
func (e LiquiditySourceResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiquiditySourceRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiquiditySourceResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiquiditySourceResValidationError{}

// Validate checks the field values on LiquidityBeneficiaryRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LiquidityBeneficiaryRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LiquidityBeneficiaryRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LiquidityBeneficiaryResMultiError, or nil if none found.
func (m *LiquidityBeneficiaryRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LiquidityBeneficiaryRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountID

	// no validation rules for AccountAlias

	// no validation rules for AccountNumber

	// no validation rules for TBAValue

	// no validation rules for Remark

	if len(errors) > 0 {
		return LiquidityBeneficiaryResMultiError(errors)
	}

	return nil
}

// LiquidityBeneficiaryResMultiError is an error wrapping multiple validation
// errors returned by LiquidityBeneficiaryRes.ValidateAll() if the designated
// constraints aren't met.
type LiquidityBeneficiaryResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LiquidityBeneficiaryResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LiquidityBeneficiaryResMultiError) AllErrors() []error { return m }

// LiquidityBeneficiaryResValidationError is the validation error returned by
// LiquidityBeneficiaryRes.Validate if the designated constraints aren't met.
type LiquidityBeneficiaryResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LiquidityBeneficiaryResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LiquidityBeneficiaryResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LiquidityBeneficiaryResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LiquidityBeneficiaryResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LiquidityBeneficiaryResValidationError) ErrorName() string {
	return "LiquidityBeneficiaryResValidationError"
}

// Error satisfies the builtin error interface
func (e LiquidityBeneficiaryResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLiquidityBeneficiaryRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LiquidityBeneficiaryResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LiquidityBeneficiaryResValidationError{}

// Validate checks the field values on CompanyCreateTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompanyCreateTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompanyCreateTaskMultiError, or nil if none found.
func (m *CompanyCreateTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyCreateTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyID

	// no validation rules for Name

	if len(errors) > 0 {
		return CompanyCreateTaskMultiError(errors)
	}

	return nil
}

// CompanyCreateTaskMultiError is an error wrapping multiple validation errors
// returned by CompanyCreateTask.ValidateAll() if the designated constraints
// aren't met.
type CompanyCreateTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyCreateTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyCreateTaskMultiError) AllErrors() []error { return m }

// CompanyCreateTaskValidationError is the validation error returned by
// CompanyCreateTask.Validate if the designated constraints aren't met.
type CompanyCreateTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyCreateTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyCreateTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyCreateTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyCreateTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyCreateTaskValidationError) ErrorName() string {
	return "CompanyCreateTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CompanyCreateTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyCreateTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyCreateTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyCreateTaskValidationError{}

// Validate checks the field values on CompanyGroupCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompanyGroupCreateTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyGroupCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompanyGroupCreateTaskMultiError, or nil if none found.
func (m *CompanyGroupCreateTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyGroupCreateTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyGroupID

	// no validation rules for Name

	if len(errors) > 0 {
		return CompanyGroupCreateTaskMultiError(errors)
	}

	return nil
}

// CompanyGroupCreateTaskMultiError is an error wrapping multiple validation
// errors returned by CompanyGroupCreateTask.ValidateAll() if the designated
// constraints aren't met.
type CompanyGroupCreateTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyGroupCreateTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyGroupCreateTaskMultiError) AllErrors() []error { return m }

// CompanyGroupCreateTaskValidationError is the validation error returned by
// CompanyGroupCreateTask.Validate if the designated constraints aren't met.
type CompanyGroupCreateTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyGroupCreateTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyGroupCreateTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyGroupCreateTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyGroupCreateTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyGroupCreateTaskValidationError) ErrorName() string {
	return "CompanyGroupCreateTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CompanyGroupCreateTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyGroupCreateTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyGroupCreateTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyGroupCreateTaskValidationError{}

// Validate checks the field values on CurrencyCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CurrencyCreateTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CurrencyCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CurrencyCreateTaskMultiError, or nil if none found.
func (m *CurrencyCreateTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CurrencyCreateTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrencyID

	// no validation rules for Name

	// no validation rules for Code

	if len(errors) > 0 {
		return CurrencyCreateTaskMultiError(errors)
	}

	return nil
}

// CurrencyCreateTaskMultiError is an error wrapping multiple validation errors
// returned by CurrencyCreateTask.ValidateAll() if the designated constraints
// aren't met.
type CurrencyCreateTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyCreateTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyCreateTaskMultiError) AllErrors() []error { return m }

// CurrencyCreateTaskValidationError is the validation error returned by
// CurrencyCreateTask.Validate if the designated constraints aren't met.
type CurrencyCreateTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyCreateTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyCreateTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyCreateTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyCreateTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyCreateTaskValidationError) ErrorName() string {
	return "CurrencyCreateTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CurrencyCreateTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrencyCreateTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyCreateTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyCreateTaskValidationError{}

// Validate checks the field values on PriorityUpdatesCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PriorityUpdatesCreateTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PriorityUpdatesCreateTask with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PriorityUpdatesCreateTaskMultiError, or nil if none found.
func (m *PriorityUpdatesCreateTask) ValidateAll() error {
	return m.validate(true)
}

func (m *PriorityUpdatesCreateTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LiquidityID

	// no validation rules for Priority

	if len(errors) > 0 {
		return PriorityUpdatesCreateTaskMultiError(errors)
	}

	return nil
}

// PriorityUpdatesCreateTaskMultiError is an error wrapping multiple validation
// errors returned by PriorityUpdatesCreateTask.ValidateAll() if the
// designated constraints aren't met.
type PriorityUpdatesCreateTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PriorityUpdatesCreateTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PriorityUpdatesCreateTaskMultiError) AllErrors() []error { return m }

// PriorityUpdatesCreateTaskValidationError is the validation error returned by
// PriorityUpdatesCreateTask.Validate if the designated constraints aren't met.
type PriorityUpdatesCreateTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PriorityUpdatesCreateTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PriorityUpdatesCreateTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PriorityUpdatesCreateTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PriorityUpdatesCreateTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PriorityUpdatesCreateTaskValidationError) ErrorName() string {
	return "PriorityUpdatesCreateTaskValidationError"
}

// Error satisfies the builtin error interface
func (e PriorityUpdatesCreateTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPriorityUpdatesCreateTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PriorityUpdatesCreateTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PriorityUpdatesCreateTaskValidationError{}

// Validate checks the field values on CashflowsCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CashflowsCreateTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CashflowsCreateTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CashflowsCreateTaskMultiError, or nil if none found.
func (m *CashflowsCreateTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CashflowsCreateTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if _, ok := _CashflowsCreateTask_CashflowType_InLookup[m.GetCashflowType()]; !ok {
		err := CashflowsCreateTaskValidationError{
			field:  "CashflowType",
			reason: "value must be in list [funding topping]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CashflowsCreateTask_Period_InLookup[m.GetPeriod()]; !ok {
		err := CashflowsCreateTaskValidationError{
			field:  "Period",
			reason: "value must be in list [daily every-few-days weekly monthly end-of-month]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPeriodTimes() {
		_, _ = idx, item

		if !_CashflowsCreateTask_PeriodTimes_Pattern.MatchString(item) {
			err := CashflowsCreateTaskValidationError{
				field:  fmt.Sprintf("PeriodTimes[%v]", idx),
				reason: "value does not match regex pattern \"^\\\\d{4} \\\\d{2}:\\\\d{2}:\\\\d{2}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _CashflowsCreateTask_TBAType_InLookup[m.GetTBAType()]; !ok {
		err := CashflowsCreateTaskValidationError{
			field:  "TBAType",
			reason: "value must be in list [range-value target-value zero-balance fixed-balance topping-value specific percentage]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TBAValue

	// no validation rules for TBARoundedBase

	// no validation rules for TBATopValue

	// no validation rules for TBABottomValue

	// no validation rules for Recurring

	if _, ok := _CashflowsCreateTask_RecurringValue_InLookup[m.GetRecurringValue()]; !ok {
		err := CashflowsCreateTaskValidationError{
			field:  "RecurringValue",
			reason: "value must be in list [ monday tuesday wednesday thursday friday saturday sunday]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RecurringDate

	// no validation rules for RecurringDays

	for idx, item := range m.GetSource() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashflowsCreateTaskValidationError{
						field:  fmt.Sprintf("Source[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashflowsCreateTaskValidationError{
						field:  fmt.Sprintf("Source[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashflowsCreateTaskValidationError{
					field:  fmt.Sprintf("Source[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBeneficiary() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashflowsCreateTaskValidationError{
						field:  fmt.Sprintf("Beneficiary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashflowsCreateTaskValidationError{
						field:  fmt.Sprintf("Beneficiary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashflowsCreateTaskValidationError{
					field:  fmt.Sprintf("Beneficiary[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CashflowsCreateTaskMultiError(errors)
	}

	return nil
}

// CashflowsCreateTaskMultiError is an error wrapping multiple validation
// errors returned by CashflowsCreateTask.ValidateAll() if the designated
// constraints aren't met.
type CashflowsCreateTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CashflowsCreateTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CashflowsCreateTaskMultiError) AllErrors() []error { return m }

// CashflowsCreateTaskValidationError is the validation error returned by
// CashflowsCreateTask.Validate if the designated constraints aren't met.
type CashflowsCreateTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CashflowsCreateTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CashflowsCreateTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CashflowsCreateTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CashflowsCreateTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CashflowsCreateTaskValidationError) ErrorName() string {
	return "CashflowsCreateTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CashflowsCreateTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCashflowsCreateTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CashflowsCreateTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CashflowsCreateTaskValidationError{}

var _CashflowsCreateTask_CashflowType_InLookup = map[string]struct{}{
	"funding": {},
	"topping": {},
}

var _CashflowsCreateTask_Period_InLookup = map[string]struct{}{
	"daily":          {},
	"every-few-days": {},
	"weekly":         {},
	"monthly":        {},
	"end-of-month":   {},
}

var _CashflowsCreateTask_PeriodTimes_Pattern = regexp.MustCompile("^\\d{4} \\d{2}:\\d{2}:\\d{2}$")

var _CashflowsCreateTask_TBAType_InLookup = map[string]struct{}{
	"range-value":   {},
	"target-value":  {},
	"zero-balance":  {},
	"fixed-balance": {},
	"topping-value": {},
	"specific":      {},
	"percentage":    {},
}

var _CashflowsCreateTask_RecurringValue_InLookup = map[string]struct{}{
	"":          {},
	"monday":    {},
	"tuesday":   {},
	"wednesday": {},
	"thursday":  {},
	"friday":    {},
	"saturday":  {},
	"sunday":    {},
}

// Validate checks the field values on CreateTaskLiquidityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTaskLiquidityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTaskLiquidityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTaskLiquidityResponseMultiError, or nil if none found.
func (m *CreateTaskLiquidityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTaskLiquidityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return CreateTaskLiquidityResponseMultiError(errors)
	}

	return nil
}

// CreateTaskLiquidityResponseMultiError is an error wrapping multiple
// validation errors returned by CreateTaskLiquidityResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateTaskLiquidityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTaskLiquidityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTaskLiquidityResponseMultiError) AllErrors() []error { return m }

// CreateTaskLiquidityResponseValidationError is the validation error returned
// by CreateTaskLiquidityResponse.Validate if the designated constraints
// aren't met.
type CreateTaskLiquidityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTaskLiquidityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTaskLiquidityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTaskLiquidityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTaskLiquidityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTaskLiquidityResponseValidationError) ErrorName() string {
	return "CreateTaskLiquidityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTaskLiquidityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTaskLiquidityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTaskLiquidityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTaskLiquidityResponseValidationError{}

// Validate checks the field values on DeleteTaskLiquidityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskLiquidityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskLiquidityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTaskLiquidityResponseMultiError, or nil if none found.
func (m *DeleteTaskLiquidityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskLiquidityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return DeleteTaskLiquidityResponseMultiError(errors)
	}

	return nil
}

// DeleteTaskLiquidityResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteTaskLiquidityResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteTaskLiquidityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskLiquidityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskLiquidityResponseMultiError) AllErrors() []error { return m }

// DeleteTaskLiquidityResponseValidationError is the validation error returned
// by DeleteTaskLiquidityResponse.Validate if the designated constraints
// aren't met.
type DeleteTaskLiquidityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskLiquidityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskLiquidityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskLiquidityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskLiquidityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskLiquidityResponseValidationError) ErrorName() string {
	return "DeleteTaskLiquidityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTaskLiquidityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskLiquidityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskLiquidityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskLiquidityResponseValidationError{}

// Validate checks the field values on DeleteLiquidityTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLiquidityTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLiquidityTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLiquidityTaskRequestMultiError, or nil if none found.
func (m *DeleteLiquidityTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLiquidityTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LiquidityID

	if len(errors) > 0 {
		return DeleteLiquidityTaskRequestMultiError(errors)
	}

	return nil
}

// DeleteLiquidityTaskRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteLiquidityTaskRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteLiquidityTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLiquidityTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLiquidityTaskRequestMultiError) AllErrors() []error { return m }

// DeleteLiquidityTaskRequestValidationError is the validation error returned
// by DeleteLiquidityTaskRequest.Validate if the designated constraints aren't met.
type DeleteLiquidityTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLiquidityTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLiquidityTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLiquidityTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLiquidityTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLiquidityTaskRequestValidationError) ErrorName() string {
	return "DeleteLiquidityTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLiquidityTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLiquidityTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLiquidityTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLiquidityTaskRequestValidationError{}

// Validate checks the field values on DeleteLiquidityTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLiquidityTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLiquidityTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLiquidityTaskResponseMultiError, or nil if none found.
func (m *DeleteLiquidityTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLiquidityTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return DeleteLiquidityTaskResponseMultiError(errors)
	}

	return nil
}

// DeleteLiquidityTaskResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteLiquidityTaskResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteLiquidityTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLiquidityTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLiquidityTaskResponseMultiError) AllErrors() []error { return m }

// DeleteLiquidityTaskResponseValidationError is the validation error returned
// by DeleteLiquidityTaskResponse.Validate if the designated constraints
// aren't met.
type DeleteLiquidityTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLiquidityTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLiquidityTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLiquidityTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLiquidityTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLiquidityTaskResponseValidationError) ErrorName() string {
	return "DeleteLiquidityTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLiquidityTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLiquidityTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLiquidityTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLiquidityTaskResponseValidationError{}

// Validate checks the field values on DeleteLiquidityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLiquidityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLiquidityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLiquidityRequestMultiError, or nil if none found.
func (m *DeleteLiquidityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLiquidityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteLiquidityRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteLiquidityRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteLiquidityRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TaskID

	if len(errors) > 0 {
		return DeleteLiquidityRequestMultiError(errors)
	}

	return nil
}

// DeleteLiquidityRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteLiquidityRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteLiquidityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLiquidityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLiquidityRequestMultiError) AllErrors() []error { return m }

// DeleteLiquidityRequestValidationError is the validation error returned by
// DeleteLiquidityRequest.Validate if the designated constraints aren't met.
type DeleteLiquidityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLiquidityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLiquidityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLiquidityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLiquidityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLiquidityRequestValidationError) ErrorName() string {
	return "DeleteLiquidityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLiquidityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLiquidityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLiquidityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLiquidityRequestValidationError{}

// Validate checks the field values on DeleteLiquidityResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLiquidityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLiquidityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLiquidityResponseMultiError, or nil if none found.
func (m *DeleteLiquidityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLiquidityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return DeleteLiquidityResponseMultiError(errors)
	}

	return nil
}

// DeleteLiquidityResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteLiquidityResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteLiquidityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLiquidityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLiquidityResponseMultiError) AllErrors() []error { return m }

// DeleteLiquidityResponseValidationError is the validation error returned by
// DeleteLiquidityResponse.Validate if the designated constraints aren't met.
type DeleteLiquidityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLiquidityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLiquidityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLiquidityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLiquidityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLiquidityResponseValidationError) ErrorName() string {
	return "DeleteLiquidityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLiquidityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLiquidityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLiquidityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLiquidityResponseValidationError{}

// Validate checks the field values on ListDataRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDataRequestMultiError, or nil if none found.
func (m *ListDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLiquidity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDataRequestValidationError{
					field:  "Liquidity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDataRequestValidationError{
					field:  "Liquidity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLiquidity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDataRequestValidationError{
				field:  "Liquidity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Limit

	// no validation rules for Page

	// no validation rules for Sort

	// no validation rules for Dir

	// no validation rules for Filter

	// no validation rules for Query

	if len(errors) > 0 {
		return ListDataRequestMultiError(errors)
	}

	return nil
}

// ListDataRequestMultiError is an error wrapping multiple validation errors
// returned by ListDataRequest.ValidateAll() if the designated constraints
// aren't met.
type ListDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDataRequestMultiError) AllErrors() []error { return m }

// ListDataRequestValidationError is the validation error returned by
// ListDataRequest.Validate if the designated constraints aren't met.
type ListDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDataRequestValidationError) ErrorName() string { return "ListDataRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDataRequestValidationError{}

// Validate checks the field values on Pagination with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pagination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pagination with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PaginationMultiError, or
// nil if none found.
func (m *Pagination) ValidateAll() error {
	return m.validate(true)
}

func (m *Pagination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for Page

	if len(errors) > 0 {
		return PaginationMultiError(errors)
	}

	return nil
}

// PaginationMultiError is an error wrapping multiple validation errors
// returned by Pagination.ValidateAll() if the designated constraints aren't met.
type PaginationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaginationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaginationMultiError) AllErrors() []error { return m }

// PaginationValidationError is the validation error returned by
// Pagination.Validate if the designated constraints aren't met.
type PaginationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaginationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaginationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaginationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaginationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaginationValidationError) ErrorName() string { return "PaginationValidationError" }

// Error satisfies the builtin error interface
func (e PaginationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaginationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaginationValidationError{}

// Validate checks the field values on Search with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Search) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Search with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SearchMultiError, or nil if none found.
func (m *Search) ValidateAll() error {
	return m.validate(true)
}

func (m *Search) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Columns

	if len(errors) > 0 {
		return SearchMultiError(errors)
	}

	return nil
}

// SearchMultiError is an error wrapping multiple validation errors returned by
// Search.ValidateAll() if the designated constraints aren't met.
type SearchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMultiError) AllErrors() []error { return m }

// SearchValidationError is the validation error returned by Search.Validate if
// the designated constraints aren't met.
type SearchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchValidationError) ErrorName() string { return "SearchValidationError" }

// Error satisfies the builtin error interface
func (e SearchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchValidationError{}

// Validate checks the field values on ListDataResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDataResponseMultiError, or nil if none found.
func (m *ListDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDataResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDataResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDataResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDataResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDataResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDataResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListDataResponseMultiError(errors)
	}

	return nil
}

// ListDataResponseMultiError is an error wrapping multiple validation errors
// returned by ListDataResponse.ValidateAll() if the designated constraints
// aren't met.
type ListDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDataResponseMultiError) AllErrors() []error { return m }

// ListDataResponseValidationError is the validation error returned by
// ListDataResponse.Validate if the designated constraints aren't met.
type ListDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDataResponseValidationError) ErrorName() string { return "ListDataResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDataResponseValidationError{}

// Validate checks the field values on ListTBAValueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTBAValueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTBAValueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTBAValueResponseMultiError, or nil if none found.
func (m *ListTBAValueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTBAValueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTBAValueResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTBAValueResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTBAValueResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTBAValueResponseMultiError(errors)
	}

	return nil
}

// ListTBAValueResponseMultiError is an error wrapping multiple validation
// errors returned by ListTBAValueResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTBAValueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTBAValueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTBAValueResponseMultiError) AllErrors() []error { return m }

// ListTBAValueResponseValidationError is the validation error returned by
// ListTBAValueResponse.Validate if the designated constraints aren't met.
type ListTBAValueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTBAValueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTBAValueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTBAValueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTBAValueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTBAValueResponseValidationError) ErrorName() string {
	return "ListTBAValueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTBAValueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTBAValueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTBAValueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTBAValueResponseValidationError{}

// Validate checks the field values on RunLiquidityTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunLiquidityTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunLiquidityTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunLiquidityTaskRequestMultiError, or nil if none found.
func (m *RunLiquidityTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RunLiquidityTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LiquidityID

	// no validation rules for CashflowID

	// no validation rules for TaskId

	if len(errors) > 0 {
		return RunLiquidityTaskRequestMultiError(errors)
	}

	return nil
}

// RunLiquidityTaskRequestMultiError is an error wrapping multiple validation
// errors returned by RunLiquidityTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type RunLiquidityTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunLiquidityTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunLiquidityTaskRequestMultiError) AllErrors() []error { return m }

// RunLiquidityTaskRequestValidationError is the validation error returned by
// RunLiquidityTaskRequest.Validate if the designated constraints aren't met.
type RunLiquidityTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunLiquidityTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunLiquidityTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunLiquidityTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunLiquidityTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunLiquidityTaskRequestValidationError) ErrorName() string {
	return "RunLiquidityTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RunLiquidityTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunLiquidityTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunLiquidityTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunLiquidityTaskRequestValidationError{}

// Validate checks the field values on RunLiquidityTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunLiquidityTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunLiquidityTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunLiquidityTaskResponseMultiError, or nil if none found.
func (m *RunLiquidityTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RunLiquidityTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunLiquidityTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunLiquidityTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunLiquidityTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RunLiquidityTaskResponseMultiError(errors)
	}

	return nil
}

// RunLiquidityTaskResponseMultiError is an error wrapping multiple validation
// errors returned by RunLiquidityTaskResponse.ValidateAll() if the designated
// constraints aren't met.
type RunLiquidityTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunLiquidityTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunLiquidityTaskResponseMultiError) AllErrors() []error { return m }

// RunLiquidityTaskResponseValidationError is the validation error returned by
// RunLiquidityTaskResponse.Validate if the designated constraints aren't met.
type RunLiquidityTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunLiquidityTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunLiquidityTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunLiquidityTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunLiquidityTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunLiquidityTaskResponseValidationError) ErrorName() string {
	return "RunLiquidityTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RunLiquidityTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunLiquidityTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunLiquidityTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunLiquidityTaskResponseValidationError{}

// Validate checks the field values on ValidateDateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidateDateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateDateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateDateRequestMultiError, or nil if none found.
func (m *ValidateDateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateDateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartDate

	// no validation rules for EndDate

	// no validation rules for PeriodType

	// no validation rules for PeriodRange

	if len(errors) > 0 {
		return ValidateDateRequestMultiError(errors)
	}

	return nil
}

// ValidateDateRequestMultiError is an error wrapping multiple validation
// errors returned by ValidateDateRequest.ValidateAll() if the designated
// constraints aren't met.
type ValidateDateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateDateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateDateRequestMultiError) AllErrors() []error { return m }

// ValidateDateRequestValidationError is the validation error returned by
// ValidateDateRequest.Validate if the designated constraints aren't met.
type ValidateDateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateDateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateDateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateDateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateDateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateDateRequestValidationError) ErrorName() string {
	return "ValidateDateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateDateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateDateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateDateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateDateRequestValidationError{}

// Validate checks the field values on ValidateDateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidateDateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateDateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateDateResponseMultiError, or nil if none found.
func (m *ValidateDateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateDateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateDateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateDateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateDateResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ValidateDateResponseMultiError(errors)
	}

	return nil
}

// ValidateDateResponseMultiError is an error wrapping multiple validation
// errors returned by ValidateDateResponse.ValidateAll() if the designated
// constraints aren't met.
type ValidateDateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateDateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateDateResponseMultiError) AllErrors() []error { return m }

// ValidateDateResponseValidationError is the validation error returned by
// ValidateDateResponse.Validate if the designated constraints aren't met.
type ValidateDateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateDateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateDateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateDateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateDateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateDateResponseValidationError) ErrorName() string {
	return "ValidateDateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateDateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateDateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateDateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateDateResponseValidationError{}

// Validate checks the field values on AvailableTime with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AvailableTime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvailableTime with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailableTimeMultiError, or
// nil if none found.
func (m *AvailableTime) ValidateAll() error {
	return m.validate(true)
}

func (m *AvailableTime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AvailableTimeMultiError(errors)
	}

	return nil
}

// AvailableTimeMultiError is an error wrapping multiple validation errors
// returned by AvailableTime.ValidateAll() if the designated constraints
// aren't met.
type AvailableTimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailableTimeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailableTimeMultiError) AllErrors() []error { return m }

// AvailableTimeValidationError is the validation error returned by
// AvailableTime.Validate if the designated constraints aren't met.
type AvailableTimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailableTimeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailableTimeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailableTimeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailableTimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailableTimeValidationError) ErrorName() string { return "AvailableTimeValidationError" }

// Error satisfies the builtin error interface
func (e AvailableTimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailableTime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailableTimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailableTimeValidationError{}

// Validate checks the field values on CreateLiquiditySchedulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLiquiditySchedulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLiquiditySchedulesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateLiquiditySchedulesRequestMultiError, or nil if none found.
func (m *CreateLiquiditySchedulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLiquiditySchedulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LiquidityCode

	if len(errors) > 0 {
		return CreateLiquiditySchedulesRequestMultiError(errors)
	}

	return nil
}

// CreateLiquiditySchedulesRequestMultiError is an error wrapping multiple
// validation errors returned by CreateLiquiditySchedulesRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateLiquiditySchedulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLiquiditySchedulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLiquiditySchedulesRequestMultiError) AllErrors() []error { return m }

// CreateLiquiditySchedulesRequestValidationError is the validation error
// returned by CreateLiquiditySchedulesRequest.Validate if the designated
// constraints aren't met.
type CreateLiquiditySchedulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLiquiditySchedulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLiquiditySchedulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLiquiditySchedulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLiquiditySchedulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLiquiditySchedulesRequestValidationError) ErrorName() string {
	return "CreateLiquiditySchedulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLiquiditySchedulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLiquiditySchedulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLiquiditySchedulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLiquiditySchedulesRequestValidationError{}

// Validate checks the field values on CreateLiquiditySchedulesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateLiquiditySchedulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLiquiditySchedulesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateLiquiditySchedulesResponseMultiError, or nil if none found.
func (m *CreateLiquiditySchedulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLiquiditySchedulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSchedules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateLiquiditySchedulesResponseValidationError{
						field:  fmt.Sprintf("Schedules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateLiquiditySchedulesResponseValidationError{
						field:  fmt.Sprintf("Schedules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateLiquiditySchedulesResponseValidationError{
					field:  fmt.Sprintf("Schedules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateLiquiditySchedulesResponseMultiError(errors)
	}

	return nil
}

// CreateLiquiditySchedulesResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateLiquiditySchedulesResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateLiquiditySchedulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLiquiditySchedulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLiquiditySchedulesResponseMultiError) AllErrors() []error { return m }

// CreateLiquiditySchedulesResponseValidationError is the validation error
// returned by CreateLiquiditySchedulesResponse.Validate if the designated
// constraints aren't met.
type CreateLiquiditySchedulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLiquiditySchedulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLiquiditySchedulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLiquiditySchedulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLiquiditySchedulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLiquiditySchedulesResponseValidationError) ErrorName() string {
	return "CreateLiquiditySchedulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLiquiditySchedulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLiquiditySchedulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLiquiditySchedulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLiquiditySchedulesResponseValidationError{}

// Validate checks the field values on CreateLiquiditySchedulesRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLiquiditySchedulesRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLiquiditySchedulesRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLiquiditySchedulesResMultiError, or nil if none found.
func (m *CreateLiquiditySchedulesRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLiquiditySchedulesRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CashflowID

	// no validation rules for LiquidityID

	if all {
		switch v := interface{}(m.GetScheduleTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLiquiditySchedulesResValidationError{
					field:  "ScheduleTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLiquiditySchedulesResValidationError{
					field:  "ScheduleTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScheduleTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLiquiditySchedulesResValidationError{
				field:  "ScheduleTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLiquiditySchedulesResMultiError(errors)
	}

	return nil
}

// CreateLiquiditySchedulesResMultiError is an error wrapping multiple
// validation errors returned by CreateLiquiditySchedulesRes.ValidateAll() if
// the designated constraints aren't met.
type CreateLiquiditySchedulesResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLiquiditySchedulesResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLiquiditySchedulesResMultiError) AllErrors() []error { return m }

// CreateLiquiditySchedulesResValidationError is the validation error returned
// by CreateLiquiditySchedulesRes.Validate if the designated constraints
// aren't met.
type CreateLiquiditySchedulesResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLiquiditySchedulesResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLiquiditySchedulesResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLiquiditySchedulesResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLiquiditySchedulesResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLiquiditySchedulesResValidationError) ErrorName() string {
	return "CreateLiquiditySchedulesResValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLiquiditySchedulesResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLiquiditySchedulesRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLiquiditySchedulesResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLiquiditySchedulesResValidationError{}

// Validate checks the field values on RunDailyScheduleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunDailyScheduleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunDailyScheduleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunDailyScheduleRequestMultiError, or nil if none found.
func (m *RunDailyScheduleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RunDailyScheduleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return RunDailyScheduleRequestMultiError(errors)
	}

	return nil
}

// RunDailyScheduleRequestMultiError is an error wrapping multiple validation
// errors returned by RunDailyScheduleRequest.ValidateAll() if the designated
// constraints aren't met.
type RunDailyScheduleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunDailyScheduleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunDailyScheduleRequestMultiError) AllErrors() []error { return m }

// RunDailyScheduleRequestValidationError is the validation error returned by
// RunDailyScheduleRequest.Validate if the designated constraints aren't met.
type RunDailyScheduleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunDailyScheduleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunDailyScheduleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunDailyScheduleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunDailyScheduleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunDailyScheduleRequestValidationError) ErrorName() string {
	return "RunDailyScheduleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RunDailyScheduleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunDailyScheduleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunDailyScheduleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunDailyScheduleRequestValidationError{}

// Validate checks the field values on RunDailyScheduleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunDailyScheduleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunDailyScheduleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunDailyScheduleResponseMultiError, or nil if none found.
func (m *RunDailyScheduleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RunDailyScheduleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return RunDailyScheduleResponseMultiError(errors)
	}

	return nil
}

// RunDailyScheduleResponseMultiError is an error wrapping multiple validation
// errors returned by RunDailyScheduleResponse.ValidateAll() if the designated
// constraints aren't met.
type RunDailyScheduleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunDailyScheduleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunDailyScheduleResponseMultiError) AllErrors() []error { return m }

// RunDailyScheduleResponseValidationError is the validation error returned by
// RunDailyScheduleResponse.Validate if the designated constraints aren't met.
type RunDailyScheduleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunDailyScheduleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunDailyScheduleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunDailyScheduleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunDailyScheduleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunDailyScheduleResponseValidationError) ErrorName() string {
	return "RunDailyScheduleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RunDailyScheduleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunDailyScheduleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunDailyScheduleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunDailyScheduleResponseValidationError{}

// Validate checks the field values on TaskActionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskActionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskActionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskActionRequestMultiError, or nil if none found.
func (m *TaskActionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskActionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskID

	// no validation rules for Action

	// no validation rules for Comment

	// no validation rules for Reasons

	// no validation rules for UserName

	// no validation rules for PassCode

	if len(errors) > 0 {
		return TaskActionRequestMultiError(errors)
	}

	return nil
}

// TaskActionRequestMultiError is an error wrapping multiple validation errors
// returned by TaskActionRequest.ValidateAll() if the designated constraints
// aren't met.
type TaskActionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskActionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskActionRequestMultiError) AllErrors() []error { return m }

// TaskActionRequestValidationError is the validation error returned by
// TaskActionRequest.Validate if the designated constraints aren't met.
type TaskActionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskActionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskActionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskActionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskActionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskActionRequestValidationError) ErrorName() string {
	return "TaskActionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TaskActionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskActionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskActionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskActionRequestValidationError{}

// Validate checks the field values on TaskActionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaskActionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskActionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskActionResponseMultiError, or nil if none found.
func (m *TaskActionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskActionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskActionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskActionResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskActionResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskActionResponseMultiError(errors)
	}

	return nil
}

// TaskActionResponseMultiError is an error wrapping multiple validation errors
// returned by TaskActionResponse.ValidateAll() if the designated constraints
// aren't met.
type TaskActionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskActionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskActionResponseMultiError) AllErrors() []error { return m }

// TaskActionResponseValidationError is the validation error returned by
// TaskActionResponse.Validate if the designated constraints aren't met.
type TaskActionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskActionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskActionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskActionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskActionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskActionResponseValidationError) ErrorName() string {
	return "TaskActionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TaskActionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskActionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskActionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskActionResponseValidationError{}

// Validate checks the field values on CreateLiquidityTransactionReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLiquidityTransactionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLiquidityTransactionReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateLiquidityTransactionReqMultiError, or nil if none found.
func (m *CreateLiquidityTransactionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLiquidityTransactionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskID

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLiquidityTransactionReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLiquidityTransactionReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLiquidityTransactionReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLiquidityTransactionReqValidationError{
					field:  "CurrentWorkflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLiquidityTransactionReqValidationError{
					field:  "CurrentWorkflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLiquidityTransactionReqValidationError{
				field:  "CurrentWorkflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLiquidityTransactionReqMultiError(errors)
	}

	return nil
}

// CreateLiquidityTransactionReqMultiError is an error wrapping multiple
// validation errors returned by CreateLiquidityTransactionReq.ValidateAll()
// if the designated constraints aren't met.
type CreateLiquidityTransactionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLiquidityTransactionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLiquidityTransactionReqMultiError) AllErrors() []error { return m }

// CreateLiquidityTransactionReqValidationError is the validation error
// returned by CreateLiquidityTransactionReq.Validate if the designated
// constraints aren't met.
type CreateLiquidityTransactionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLiquidityTransactionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLiquidityTransactionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLiquidityTransactionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLiquidityTransactionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLiquidityTransactionReqValidationError) ErrorName() string {
	return "CreateLiquidityTransactionReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLiquidityTransactionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLiquidityTransactionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLiquidityTransactionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLiquidityTransactionReqValidationError{}

// Validate checks the field values on CreateLiquidityTransactionRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLiquidityTransactionRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLiquidityTransactionRes with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateLiquidityTransactionResMultiError, or nil if none found.
func (m *CreateLiquidityTransactionRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLiquidityTransactionRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return CreateLiquidityTransactionResMultiError(errors)
	}

	return nil
}

// CreateLiquidityTransactionResMultiError is an error wrapping multiple
// validation errors returned by CreateLiquidityTransactionRes.ValidateAll()
// if the designated constraints aren't met.
type CreateLiquidityTransactionResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLiquidityTransactionResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLiquidityTransactionResMultiError) AllErrors() []error { return m }

// CreateLiquidityTransactionResValidationError is the validation error
// returned by CreateLiquidityTransactionRes.Validate if the designated
// constraints aren't met.
type CreateLiquidityTransactionResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLiquidityTransactionResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLiquidityTransactionResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLiquidityTransactionResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLiquidityTransactionResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLiquidityTransactionResValidationError) ErrorName() string {
	return "CreateLiquidityTransactionResValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLiquidityTransactionResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLiquidityTransactionRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLiquidityTransactionResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLiquidityTransactionResValidationError{}

// Validate checks the field values on ValidateWorkflowData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidateWorkflowData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateWorkflowData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateWorkflowDataMultiError, or nil if none found.
func (m *ValidateWorkflowData) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateWorkflowData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWorkflow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateWorkflowDataValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateWorkflowDataValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateWorkflowDataValidationError{
				field:  "Workflow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NextStatus

	// no validation rules for NextStep

	if len(errors) > 0 {
		return ValidateWorkflowDataMultiError(errors)
	}

	return nil
}

// ValidateWorkflowDataMultiError is an error wrapping multiple validation
// errors returned by ValidateWorkflowData.ValidateAll() if the designated
// constraints aren't met.
type ValidateWorkflowDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateWorkflowDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateWorkflowDataMultiError) AllErrors() []error { return m }

// ValidateWorkflowDataValidationError is the validation error returned by
// ValidateWorkflowData.Validate if the designated constraints aren't met.
type ValidateWorkflowDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateWorkflowDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateWorkflowDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateWorkflowDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateWorkflowDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateWorkflowDataValidationError) ErrorName() string {
	return "ValidateWorkflowDataValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateWorkflowDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateWorkflowData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateWorkflowDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateWorkflowDataValidationError{}

// Validate checks the field values on WorkflowPayload with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkflowPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkflowPayloadMultiError, or nil if none found.
func (m *WorkflowPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowPayloadValidationError{
				field:  "Header",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRecords()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "Records",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "Records",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecords()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowPayloadValidationError{
				field:  "Records",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "CreatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "CreatedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowPayloadValidationError{
				field:  "CreatedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowPayloadValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowPayloadValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsDefault

	// no validation rules for IsTransactional

	// no validation rules for CurrentStep

	if len(errors) > 0 {
		return WorkflowPayloadMultiError(errors)
	}

	return nil
}

// WorkflowPayloadMultiError is an error wrapping multiple validation errors
// returned by WorkflowPayload.ValidateAll() if the designated constraints
// aren't met.
type WorkflowPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowPayloadMultiError) AllErrors() []error { return m }

// WorkflowPayloadValidationError is the validation error returned by
// WorkflowPayload.Validate if the designated constraints aren't met.
type WorkflowPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowPayloadValidationError) ErrorName() string { return "WorkflowPayloadValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowPayloadValidationError{}

// Validate checks the field values on WorkflowHeader with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkflowHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowHeader with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowHeaderMultiError,
// or nil if none found.
func (m *WorkflowHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductID

	// no validation rules for ProductName

	// no validation rules for CurrencyID

	// no validation rules for CurrencyName

	// no validation rules for CompanyID

	// no validation rules for CompanyName

	// no validation rules for TransactionalNumber

	// no validation rules for WorkflowID

	if len(errors) > 0 {
		return WorkflowHeaderMultiError(errors)
	}

	return nil
}

// WorkflowHeaderMultiError is an error wrapping multiple validation errors
// returned by WorkflowHeader.ValidateAll() if the designated constraints
// aren't met.
type WorkflowHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowHeaderMultiError) AllErrors() []error { return m }

// WorkflowHeaderValidationError is the validation error returned by
// WorkflowHeader.Validate if the designated constraints aren't met.
type WorkflowHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowHeaderValidationError) ErrorName() string { return "WorkflowHeaderValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowHeaderValidationError{}

// Validate checks the field values on WorkflowRecords with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkflowRecords) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowRecords with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkflowRecordsMultiError, or nil if none found.
func (m *WorkflowRecords) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowRecords) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLastUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowRecordsValidationError{
					field:  "LastUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowRecordsValidationError{
					field:  "LastUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowRecordsValidationError{
				field:  "LastUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TopRange

	// no validation rules for BottomRange

	for idx, item := range m.GetFlows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkflowRecordsValidationError{
						field:  fmt.Sprintf("Flows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkflowRecordsValidationError{
						field:  fmt.Sprintf("Flows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkflowRecordsValidationError{
					field:  fmt.Sprintf("Flows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkflowRecordsMultiError(errors)
	}

	return nil
}

// WorkflowRecordsMultiError is an error wrapping multiple validation errors
// returned by WorkflowRecords.ValidateAll() if the designated constraints
// aren't met.
type WorkflowRecordsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowRecordsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowRecordsMultiError) AllErrors() []error { return m }

// WorkflowRecordsValidationError is the validation error returned by
// WorkflowRecords.Validate if the designated constraints aren't met.
type WorkflowRecordsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowRecordsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowRecordsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowRecordsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowRecordsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowRecordsValidationError) ErrorName() string { return "WorkflowRecordsValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowRecordsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowRecords.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowRecordsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowRecordsValidationError{}

// Validate checks the field values on UserData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserDataMultiError, or nil
// if none found.
func (m *UserData) ValidateAll() error {
	return m.validate(true)
}

func (m *UserData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for Username

	if len(errors) > 0 {
		return UserDataMultiError(errors)
	}

	return nil
}

// UserDataMultiError is an error wrapping multiple validation errors returned
// by UserData.ValidateAll() if the designated constraints aren't met.
type UserDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserDataMultiError) AllErrors() []error { return m }

// UserDataValidationError is the validation error returned by
// UserData.Validate if the designated constraints aren't met.
type UserDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserDataValidationError) ErrorName() string { return "UserDataValidationError" }

// Error satisfies the builtin error interface
func (e UserDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserDataValidationError{}

// Validate checks the field values on Flow with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Flow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Flow with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FlowMultiError, or nil if none found.
func (m *Flow) ValidateAll() error {
	return m.validate(true)
}

func (m *Flow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WorkflowLogicID

	if all {
		switch v := interface{}(m.GetVerifier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "Verifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "Verifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerifier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Verifier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApprover()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "Approver",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "Approver",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprover()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Approver",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReleaser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "Releaser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "Releaser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "Releaser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsRejected

	if all {
		switch v := interface{}(m.GetCompletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowValidationError{
				field:  "CompletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FlowMultiError(errors)
	}

	return nil
}

// FlowMultiError is an error wrapping multiple validation errors returned by
// Flow.ValidateAll() if the designated constraints aren't met.
type FlowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowMultiError) AllErrors() []error { return m }

// FlowValidationError is the validation error returned by Flow.Validate if the
// designated constraints aren't met.
type FlowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowValidationError) ErrorName() string { return "FlowValidationError" }

// Error satisfies the builtin error interface
func (e FlowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowValidationError{}

// Validate checks the field values on Participants with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Participants) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Participants with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParticipantsMultiError, or
// nil if none found.
func (m *Participants) ValidateAll() error {
	return m.validate(true)
}

func (m *Participants) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApprovedCount

	// no validation rules for RejectedCount

	// no validation rules for Requirement

	for idx, item := range m.GetParticipants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParticipantsValidationError{
						field:  fmt.Sprintf("Participants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParticipantsValidationError{
						field:  fmt.Sprintf("Participants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParticipantsValidationError{
					field:  fmt.Sprintf("Participants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParticipantsMultiError(errors)
	}

	return nil
}

// ParticipantsMultiError is an error wrapping multiple validation errors
// returned by Participants.ValidateAll() if the designated constraints aren't met.
type ParticipantsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantsMultiError) AllErrors() []error { return m }

// ParticipantsValidationError is the validation error returned by
// Participants.Validate if the designated constraints aren't met.
type ParticipantsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantsValidationError) ErrorName() string { return "ParticipantsValidationError" }

// Error satisfies the builtin error interface
func (e ParticipantsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipants.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantsValidationError{}

// Validate checks the field values on Participant with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Participant) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Participant with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParticipantMultiError, or
// nil if none found.
func (m *Participant) ValidateAll() error {
	return m.validate(true)
}

func (m *Participant) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for UserName

	// no validation rules for RoleID

	// no validation rules for IsReject

	if all {
		switch v := interface{}(m.GetApprovedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParticipantValidationError{
					field:  "ApprovedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParticipantValidationError{
					field:  "ApprovedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprovedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParticipantValidationError{
				field:  "ApprovedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Step

	if len(errors) > 0 {
		return ParticipantMultiError(errors)
	}

	return nil
}

// ParticipantMultiError is an error wrapping multiple validation errors
// returned by Participant.ValidateAll() if the designated constraints aren't met.
type ParticipantMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParticipantMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParticipantMultiError) AllErrors() []error { return m }

// ParticipantValidationError is the validation error returned by
// Participant.Validate if the designated constraints aren't met.
type ParticipantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParticipantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParticipantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParticipantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParticipantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParticipantValidationError) ErrorName() string { return "ParticipantValidationError" }

// Error satisfies the builtin error interface
func (e ParticipantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParticipant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParticipantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParticipantValidationError{}

// Validate checks the field values on Task with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Task) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaskMultiError, or nil if none found.
func (m *Task) ValidateAll() error {
	return m.validate(true)
}

func (m *Task) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskID

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for Step

	// no validation rules for FeatureID

	// no validation rules for LastApprovedByID

	// no validation rules for LastRejectedByID

	// no validation rules for LastApprovedByName

	// no validation rules for LastRejectedByName

	// no validation rules for CreatedByName

	// no validation rules for UpdatedByName

	// no validation rules for Reasons

	// no validation rules for Comment

	// no validation rules for CompanyID

	// no validation rules for HoldingID

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskMultiError(errors)
	}

	return nil
}

// TaskMultiError is an error wrapping multiple validation errors returned by
// Task.ValidateAll() if the designated constraints aren't met.
type TaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskMultiError) AllErrors() []error { return m }

// TaskValidationError is the validation error returned by Task.Validate if the
// designated constraints aren't met.
type TaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskValidationError) ErrorName() string { return "TaskValidationError" }

// Error satisfies the builtin error interface
func (e TaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskValidationError{}

// Validate checks the field values on ExecCashPoolingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecCashPoolingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecCashPoolingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecCashPoolingRequestMultiError, or nil if none found.
func (m *ExecCashPoolingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecCashPoolingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ExecCashPoolingRequestMultiError(errors)
	}

	return nil
}

// ExecCashPoolingRequestMultiError is an error wrapping multiple validation
// errors returned by ExecCashPoolingRequest.ValidateAll() if the designated
// constraints aren't met.
type ExecCashPoolingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecCashPoolingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecCashPoolingRequestMultiError) AllErrors() []error { return m }

// ExecCashPoolingRequestValidationError is the validation error returned by
// ExecCashPoolingRequest.Validate if the designated constraints aren't met.
type ExecCashPoolingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecCashPoolingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecCashPoolingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecCashPoolingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecCashPoolingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecCashPoolingRequestValidationError) ErrorName() string {
	return "ExecCashPoolingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExecCashPoolingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecCashPoolingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecCashPoolingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecCashPoolingRequestValidationError{}

// Validate checks the field values on ExecCashPoolingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecCashPoolingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecCashPoolingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecCashPoolingResponseMultiError, or nil if none found.
func (m *ExecCashPoolingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecCashPoolingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for JournalSequence

	// no validation rules for Status

	// no validation rules for ResponseDetail

	if len(errors) > 0 {
		return ExecCashPoolingResponseMultiError(errors)
	}

	return nil
}

// ExecCashPoolingResponseMultiError is an error wrapping multiple validation
// errors returned by ExecCashPoolingResponse.ValidateAll() if the designated
// constraints aren't met.
type ExecCashPoolingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecCashPoolingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecCashPoolingResponseMultiError) AllErrors() []error { return m }

// ExecCashPoolingResponseValidationError is the validation error returned by
// ExecCashPoolingResponse.Validate if the designated constraints aren't met.
type ExecCashPoolingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecCashPoolingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecCashPoolingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecCashPoolingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecCashPoolingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecCashPoolingResponseValidationError) ErrorName() string {
	return "ExecCashPoolingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExecCashPoolingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecCashPoolingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecCashPoolingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecCashPoolingResponseValidationError{}
