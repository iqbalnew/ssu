package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type AbonnementORM struct {
	AbonnementAccounts []*AbonnementAccountORM `gorm:"foreignkey:abonnement_id;association_foreignkey:Id;preload:true"`
	AbonnementInvoices []*AbonnementInvoiceORM `gorm:"foreignkey:abonnement_id;association_foreignkey:Id;preload:true"`
	AbonnementRetries  []*AbonnementRetryORM   `gorm:"foreignkey:abonnement_id;association_foreignkey:Id;preload:true"`
	Amount             float32                 `gorm:"not null"`
	BillingStatus      string
	CompanyID          uint64 `gorm:"not null"`
	CreatedAt          *time.Time
	CreatedByID        uint64
	CustomAbonnements  []*CustomAbonnementORM `gorm:"foreignkey:abonnement_id;association_foreignkey:Id;preload:true"`
	DeadlineDate       *time.Time             `gorm:"not null"`
	Id                 uint64                 `gorm:"primary_key;not null"`
	MechanismAccountID uint64
	MechanismType      string
	MechanismValue     float32
	Period             string `gorm:"not null"`
	UpdatedAt          *time.Time
	UpdatedByID        uint64
}

// TableName overrides the default tablename generated by GORM
func (AbonnementORM) TableName() string {
	return "abonnements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Abonnement) ToORM(ctx context.Context) (AbonnementORM, error) {
	to := AbonnementORM{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyID = m.CompanyID
	to.Amount = m.Amount
	if m.DeadlineDate != nil {
		t := m.DeadlineDate.AsTime()
		to.DeadlineDate = &t
	}
	to.Period = m.Period
	to.MechanismType = m.MechanismType
	to.MechanismValue = m.MechanismValue
	to.MechanismAccountID = m.MechanismAccountID
	to.BillingStatus = m.BillingStatus
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.AbonnementAccounts {
		if v != nil {
			if tempAbonnementAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.AbonnementAccounts = append(to.AbonnementAccounts, &tempAbonnementAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.AbonnementAccounts = append(to.AbonnementAccounts, nil)
		}
	}
	for _, v := range m.AbonnementInvoices {
		if v != nil {
			if tempAbonnementInvoices, cErr := v.ToORM(ctx); cErr == nil {
				to.AbonnementInvoices = append(to.AbonnementInvoices, &tempAbonnementInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.AbonnementInvoices = append(to.AbonnementInvoices, nil)
		}
	}
	for _, v := range m.AbonnementRetries {
		if v != nil {
			if tempAbonnementRetries, cErr := v.ToORM(ctx); cErr == nil {
				to.AbonnementRetries = append(to.AbonnementRetries, &tempAbonnementRetries)
			} else {
				return to, cErr
			}
		} else {
			to.AbonnementRetries = append(to.AbonnementRetries, nil)
		}
	}
	for _, v := range m.CustomAbonnements {
		if v != nil {
			if tempCustomAbonnements, cErr := v.ToORM(ctx); cErr == nil {
				to.CustomAbonnements = append(to.CustomAbonnements, &tempCustomAbonnements)
			} else {
				return to, cErr
			}
		} else {
			to.CustomAbonnements = append(to.CustomAbonnements, nil)
		}
	}
	if posthook, ok := interface{}(m).(AbonnementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AbonnementORM) ToPB(ctx context.Context) (Abonnement, error) {
	to := Abonnement{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyID = m.CompanyID
	to.Amount = m.Amount
	if m.DeadlineDate != nil {
		to.DeadlineDate = timestamppb.New(*m.DeadlineDate)
	}
	to.Period = m.Period
	to.MechanismType = m.MechanismType
	to.MechanismValue = m.MechanismValue
	to.MechanismAccountID = m.MechanismAccountID
	to.BillingStatus = m.BillingStatus
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.AbonnementAccounts {
		if v != nil {
			if tempAbonnementAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.AbonnementAccounts = append(to.AbonnementAccounts, &tempAbonnementAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.AbonnementAccounts = append(to.AbonnementAccounts, nil)
		}
	}
	for _, v := range m.AbonnementInvoices {
		if v != nil {
			if tempAbonnementInvoices, cErr := v.ToPB(ctx); cErr == nil {
				to.AbonnementInvoices = append(to.AbonnementInvoices, &tempAbonnementInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.AbonnementInvoices = append(to.AbonnementInvoices, nil)
		}
	}
	for _, v := range m.AbonnementRetries {
		if v != nil {
			if tempAbonnementRetries, cErr := v.ToPB(ctx); cErr == nil {
				to.AbonnementRetries = append(to.AbonnementRetries, &tempAbonnementRetries)
			} else {
				return to, cErr
			}
		} else {
			to.AbonnementRetries = append(to.AbonnementRetries, nil)
		}
	}
	for _, v := range m.CustomAbonnements {
		if v != nil {
			if tempCustomAbonnements, cErr := v.ToPB(ctx); cErr == nil {
				to.CustomAbonnements = append(to.CustomAbonnements, &tempCustomAbonnements)
			} else {
				return to, cErr
			}
		} else {
			to.CustomAbonnements = append(to.CustomAbonnements, nil)
		}
	}
	if posthook, ok := interface{}(m).(AbonnementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Abonnement the arg will be the target, the caller the one being converted from

// AbonnementBeforeToORM called before default ToORM code
type AbonnementWithBeforeToORM interface {
	BeforeToORM(context.Context, *AbonnementORM) error
}

// AbonnementAfterToORM called after default ToORM code
type AbonnementWithAfterToORM interface {
	AfterToORM(context.Context, *AbonnementORM) error
}

// AbonnementBeforeToPB called before default ToPB code
type AbonnementWithBeforeToPB interface {
	BeforeToPB(context.Context, *Abonnement) error
}

// AbonnementAfterToPB called after default ToPB code
type AbonnementWithAfterToPB interface {
	AfterToPB(context.Context, *Abonnement) error
}

type AbonnementRetryORM struct {
	Abonnement    *AbonnementORM `gorm:"foreignkey:AbonnementId;association_foreignkey:Id"`
	AbonnementID  uint64
	AbonnementId  *uint64
	CreatedAt     *time.Time
	CreatedByID   uint64
	Id            uint64 `gorm:"primary_key;not null"`
	RetryDate     *time.Time
	UpdatedAt     *time.Time
	UpdatedByID   uint64
	abonnement_id *uint64
}

// TableName overrides the default tablename generated by GORM
func (AbonnementRetryORM) TableName() string {
	return "abonnement_retries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AbonnementRetry) ToORM(ctx context.Context) (AbonnementRetryORM, error) {
	to := AbonnementRetryORM{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementRetryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	if m.RetryDate != nil {
		t := m.RetryDate.AsTime()
		to.RetryDate = &t
	}
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(AbonnementRetryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AbonnementRetryORM) ToPB(ctx context.Context) (AbonnementRetry, error) {
	to := AbonnementRetry{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementRetryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	if m.RetryDate != nil {
		to.RetryDate = timestamppb.New(*m.RetryDate)
	}
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AbonnementRetryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AbonnementRetry the arg will be the target, the caller the one being converted from

// AbonnementRetryBeforeToORM called before default ToORM code
type AbonnementRetryWithBeforeToORM interface {
	BeforeToORM(context.Context, *AbonnementRetryORM) error
}

// AbonnementRetryAfterToORM called after default ToORM code
type AbonnementRetryWithAfterToORM interface {
	AfterToORM(context.Context, *AbonnementRetryORM) error
}

// AbonnementRetryBeforeToPB called before default ToPB code
type AbonnementRetryWithBeforeToPB interface {
	BeforeToPB(context.Context, *AbonnementRetry) error
}

// AbonnementRetryAfterToPB called after default ToPB code
type AbonnementRetryWithAfterToPB interface {
	AfterToPB(context.Context, *AbonnementRetry) error
}

type AbonnementAccountORM struct {
	Abonnement    *AbonnementORM `gorm:"foreignkey:AbonnementId;association_foreignkey:Id"`
	AbonnementID  uint64
	AbonnementId  *uint64
	AccountAlias  string
	AccountID     uint64
	AccountNumber string
	CreatedAt     *time.Time
	CreatedByID   uint64
	Id            uint64 `gorm:"primary_key;not null"`
	Order         uint64
	UpdatedAt     *time.Time
	UpdatedByID   uint64
	abonnement_id *uint64
}

// TableName overrides the default tablename generated by GORM
func (AbonnementAccountORM) TableName() string {
	return "abonnement_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AbonnementAccount) ToORM(ctx context.Context) (AbonnementAccountORM, error) {
	to := AbonnementAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	to.Order = m.Order
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(AbonnementAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AbonnementAccountORM) ToPB(ctx context.Context) (AbonnementAccount, error) {
	to := AbonnementAccount{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	to.Order = m.Order
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(AbonnementAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AbonnementAccount the arg will be the target, the caller the one being converted from

// AbonnementAccountBeforeToORM called before default ToORM code
type AbonnementAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *AbonnementAccountORM) error
}

// AbonnementAccountAfterToORM called after default ToORM code
type AbonnementAccountWithAfterToORM interface {
	AfterToORM(context.Context, *AbonnementAccountORM) error
}

// AbonnementAccountBeforeToPB called before default ToPB code
type AbonnementAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *AbonnementAccount) error
}

// AbonnementAccountAfterToPB called after default ToPB code
type AbonnementAccountWithAfterToPB interface {
	AfterToPB(context.Context, *AbonnementAccount) error
}

type AbonnementInvoiceORM struct {
	Abonnement    *AbonnementORM `gorm:"foreignkey:AbonnementId;association_foreignkey:Id"`
	AbonnementID  uint64
	AbonnementId  *uint64
	AccountAlias  string
	AccountID     uint64
	AccountNumber string
	Amount        uint64
	CreatedAt     *time.Time
	CreatedByID   uint64
	DeadlineDate  *time.Time
	Id            uint64 `gorm:"primary_key;not null"`
	InvoiceCode   string
	PeriodCode    string
	Status        string
	abonnement_id *uint64
}

// TableName overrides the default tablename generated by GORM
func (AbonnementInvoiceORM) TableName() string {
	return "abonnement_invoices"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AbonnementInvoice) ToORM(ctx context.Context) (AbonnementInvoiceORM, error) {
	to := AbonnementInvoiceORM{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementInvoiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.InvoiceCode = m.InvoiceCode
	to.Id = m.Id
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	to.PeriodCode = m.PeriodCode
	to.Amount = m.Amount
	to.Status = m.Status
	if m.DeadlineDate != nil {
		t := m.DeadlineDate.AsTime()
		to.DeadlineDate = &t
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	to.CreatedByID = m.CreatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(AbonnementInvoiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AbonnementInvoiceORM) ToPB(ctx context.Context) (AbonnementInvoice, error) {
	to := AbonnementInvoice{}
	var err error
	if prehook, ok := interface{}(m).(AbonnementInvoiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.InvoiceCode = m.InvoiceCode
	to.Id = m.Id
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	to.PeriodCode = m.PeriodCode
	to.Amount = m.Amount
	to.Status = m.Status
	if m.DeadlineDate != nil {
		to.DeadlineDate = timestamppb.New(*m.DeadlineDate)
	}
	to.AccountID = m.AccountID
	to.AccountAlias = m.AccountAlias
	to.AccountNumber = m.AccountNumber
	to.CreatedByID = m.CreatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(AbonnementInvoiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AbonnementInvoice the arg will be the target, the caller the one being converted from

// AbonnementInvoiceBeforeToORM called before default ToORM code
type AbonnementInvoiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *AbonnementInvoiceORM) error
}

// AbonnementInvoiceAfterToORM called after default ToORM code
type AbonnementInvoiceWithAfterToORM interface {
	AfterToORM(context.Context, *AbonnementInvoiceORM) error
}

// AbonnementInvoiceBeforeToPB called before default ToPB code
type AbonnementInvoiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *AbonnementInvoice) error
}

// AbonnementInvoiceAfterToPB called after default ToPB code
type AbonnementInvoiceWithAfterToPB interface {
	AfterToPB(context.Context, *AbonnementInvoice) error
}

type CustomAbonnementORM struct {
	Abonnement    *AbonnementORM `gorm:"foreignkey:AbonnementId;association_foreignkey:Id"`
	AbonnementID  uint64
	AbonnementId  *uint64
	Amount        uint64
	Id            uint64 `gorm:"primary_key;not null"`
	Type          string
	Value         uint64
	abonnement_id *uint64
}

// TableName overrides the default tablename generated by GORM
func (CustomAbonnementORM) TableName() string {
	return "abonnement_custom"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CustomAbonnement) ToORM(ctx context.Context) (CustomAbonnementORM, error) {
	to := CustomAbonnementORM{}
	var err error
	if prehook, ok := interface{}(m).(CustomAbonnementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Value = m.Value
	to.Amount = m.Amount
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	if posthook, ok := interface{}(m).(CustomAbonnementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CustomAbonnementORM) ToPB(ctx context.Context) (CustomAbonnement, error) {
	to := CustomAbonnement{}
	var err error
	if prehook, ok := interface{}(m).(CustomAbonnementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Value = m.Value
	to.Amount = m.Amount
	to.AbonnementID = m.AbonnementID
	if m.Abonnement != nil {
		tempAbonnement, err := m.Abonnement.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Abonnement = &tempAbonnement
	}
	if posthook, ok := interface{}(m).(CustomAbonnementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CustomAbonnement the arg will be the target, the caller the one being converted from

// CustomAbonnementBeforeToORM called before default ToORM code
type CustomAbonnementWithBeforeToORM interface {
	BeforeToORM(context.Context, *CustomAbonnementORM) error
}

// CustomAbonnementAfterToORM called after default ToORM code
type CustomAbonnementWithAfterToORM interface {
	AfterToORM(context.Context, *CustomAbonnementORM) error
}

// CustomAbonnementBeforeToPB called before default ToPB code
type CustomAbonnementWithBeforeToPB interface {
	BeforeToPB(context.Context, *CustomAbonnement) error
}

// CustomAbonnementAfterToPB called after default ToPB code
type CustomAbonnementWithAfterToPB interface {
	AfterToPB(context.Context, *CustomAbonnement) error
}

// DefaultCreateAbonnement executes a basic gorm create call
func DefaultCreateAbonnement(ctx context.Context, in *Abonnement, db *gorm.DB) (*Abonnement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAbonnement(ctx context.Context, in *Abonnement, db *gorm.DB) (*Abonnement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AbonnementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AbonnementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AbonnementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnement(ctx context.Context, in *Abonnement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AbonnementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AbonnementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementSet(ctx context.Context, in []*Abonnement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AbonnementORM{})).(AbonnementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AbonnementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AbonnementORM{})).(AbonnementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AbonnementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Abonnement, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Abonnement, *gorm.DB) error
}

// DefaultStrictUpdateAbonnement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAbonnement(ctx context.Context, in *Abonnement, db *gorm.DB) (*Abonnement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAbonnement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AbonnementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAbonnementAccounts := AbonnementAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAbonnementAccounts.abonnement_id = new(uint64)
	*filterAbonnementAccounts.abonnement_id = ormObj.Id
	if err = db.Where(filterAbonnementAccounts).Delete(AbonnementAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterAbonnementInvoices := AbonnementInvoiceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAbonnementInvoices.abonnement_id = new(uint64)
	*filterAbonnementInvoices.abonnement_id = ormObj.Id
	if err = db.Where(filterAbonnementInvoices).Delete(AbonnementInvoiceORM{}).Error; err != nil {
		return nil, err
	}
	filterAbonnementRetries := AbonnementRetryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAbonnementRetries.abonnement_id = new(uint64)
	*filterAbonnementRetries.abonnement_id = ormObj.Id
	if err = db.Where(filterAbonnementRetries).Delete(AbonnementRetryORM{}).Error; err != nil {
		return nil, err
	}
	filterCustomAbonnements := CustomAbonnementORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCustomAbonnements.abonnement_id = new(uint64)
	*filterCustomAbonnements.abonnement_id = ormObj.Id
	if err = db.Where(filterCustomAbonnements).Delete(CustomAbonnementORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AbonnementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAbonnement executes a basic gorm update call with patch behavior
func DefaultPatchAbonnement(ctx context.Context, in *Abonnement, updateMask *field_mask.FieldMask, db *gorm.DB) (*Abonnement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Abonnement
	var err error
	if hook, ok := interface{}(&pbObj).(AbonnementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAbonnement(ctx, &Abonnement{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AbonnementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAbonnement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AbonnementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAbonnement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AbonnementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AbonnementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Abonnement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Abonnement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Abonnement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Abonnement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAbonnement executes a bulk gorm update call with patch behavior
func DefaultPatchSetAbonnement(ctx context.Context, objects []*Abonnement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Abonnement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Abonnement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAbonnement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAbonnement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAbonnement(ctx context.Context, patchee *Abonnement, patcher *Abonnement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Abonnement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDeadlineDate bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if !updatedDeadlineDate && strings.HasPrefix(f, prefix+"DeadlineDate.") {
			if patcher.DeadlineDate == nil {
				patchee.DeadlineDate = nil
				continue
			}
			if patchee.DeadlineDate == nil {
				patchee.DeadlineDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeadlineDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeadlineDate, patchee.DeadlineDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeadlineDate" {
			updatedDeadlineDate = true
			patchee.DeadlineDate = patcher.DeadlineDate
			continue
		}
		if f == prefix+"Period" {
			patchee.Period = patcher.Period
			continue
		}
		if f == prefix+"MechanismType" {
			patchee.MechanismType = patcher.MechanismType
			continue
		}
		if f == prefix+"MechanismValue" {
			patchee.MechanismValue = patcher.MechanismValue
			continue
		}
		if f == prefix+"MechanismAccountID" {
			patchee.MechanismAccountID = patcher.MechanismAccountID
			continue
		}
		if f == prefix+"BillingStatus" {
			patchee.BillingStatus = patcher.BillingStatus
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"AbonnementAccounts" {
			patchee.AbonnementAccounts = patcher.AbonnementAccounts
			continue
		}
		if f == prefix+"AbonnementInvoices" {
			patchee.AbonnementInvoices = patcher.AbonnementInvoices
			continue
		}
		if f == prefix+"AbonnementRetries" {
			patchee.AbonnementRetries = patcher.AbonnementRetries
			continue
		}
		if f == prefix+"CustomAbonnements" {
			patchee.CustomAbonnements = patcher.CustomAbonnements
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAbonnement executes a gorm list call
func DefaultListAbonnement(ctx context.Context, db *gorm.DB) ([]*Abonnement, error) {
	in := Abonnement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AbonnementORM{}, &Abonnement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AbonnementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Abonnement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AbonnementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AbonnementORM) error
}

// DefaultCreateAbonnementRetry executes a basic gorm create call
func DefaultCreateAbonnementRetry(ctx context.Context, in *AbonnementRetry, db *gorm.DB) (*AbonnementRetry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementRetryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAbonnementRetry(ctx context.Context, in *AbonnementRetry, db *gorm.DB) (*AbonnementRetry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AbonnementRetryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AbonnementRetryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AbonnementRetryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementRetryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementRetry(ctx context.Context, in *AbonnementRetry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AbonnementRetryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AbonnementRetryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementRetrySet(ctx context.Context, in []*AbonnementRetry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AbonnementRetryORM{})).(AbonnementRetryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AbonnementRetryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AbonnementRetryORM{})).(AbonnementRetryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AbonnementRetryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AbonnementRetry, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AbonnementRetry, *gorm.DB) error
}

// DefaultStrictUpdateAbonnementRetry clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAbonnementRetry(ctx context.Context, in *AbonnementRetry, db *gorm.DB) (*AbonnementRetry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAbonnementRetry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AbonnementRetryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AbonnementRetryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAbonnementRetry executes a basic gorm update call with patch behavior
func DefaultPatchAbonnementRetry(ctx context.Context, in *AbonnementRetry, updateMask *field_mask.FieldMask, db *gorm.DB) (*AbonnementRetry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AbonnementRetry
	var err error
	if hook, ok := interface{}(&pbObj).(AbonnementRetryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAbonnementRetry(ctx, &AbonnementRetry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AbonnementRetryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAbonnementRetry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AbonnementRetryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAbonnementRetry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AbonnementRetryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AbonnementRetryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AbonnementRetry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AbonnementRetry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AbonnementRetry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AbonnementRetry, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAbonnementRetry executes a bulk gorm update call with patch behavior
func DefaultPatchSetAbonnementRetry(ctx context.Context, objects []*AbonnementRetry, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AbonnementRetry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AbonnementRetry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAbonnementRetry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAbonnementRetry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAbonnementRetry(ctx context.Context, patchee *AbonnementRetry, patcher *AbonnementRetry, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AbonnementRetry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAbonnement bool
	var updatedRetryDate bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AbonnementID" {
			patchee.AbonnementID = patcher.AbonnementID
			continue
		}
		if !updatedAbonnement && strings.HasPrefix(f, prefix+"Abonnement.") {
			updatedAbonnement = true
			if patcher.Abonnement == nil {
				patchee.Abonnement = nil
				continue
			}
			if patchee.Abonnement == nil {
				patchee.Abonnement = &Abonnement{}
			}
			if o, err := DefaultApplyFieldMaskAbonnement(ctx, patchee.Abonnement, patcher.Abonnement, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Abonnement.", db); err != nil {
				return nil, err
			} else {
				patchee.Abonnement = o
			}
			continue
		}
		if f == prefix+"Abonnement" {
			updatedAbonnement = true
			patchee.Abonnement = patcher.Abonnement
			continue
		}
		if !updatedRetryDate && strings.HasPrefix(f, prefix+"RetryDate.") {
			if patcher.RetryDate == nil {
				patchee.RetryDate = nil
				continue
			}
			if patchee.RetryDate == nil {
				patchee.RetryDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RetryDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RetryDate, patchee.RetryDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RetryDate" {
			updatedRetryDate = true
			patchee.RetryDate = patcher.RetryDate
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAbonnementRetry executes a gorm list call
func DefaultListAbonnementRetry(ctx context.Context, db *gorm.DB) ([]*AbonnementRetry, error) {
	in := AbonnementRetry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AbonnementRetryORM{}, &AbonnementRetry{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AbonnementRetryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementRetryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AbonnementRetry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AbonnementRetryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementRetryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AbonnementRetryORM) error
}

// DefaultCreateAbonnementAccount executes a basic gorm create call
func DefaultCreateAbonnementAccount(ctx context.Context, in *AbonnementAccount, db *gorm.DB) (*AbonnementAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAbonnementAccount(ctx context.Context, in *AbonnementAccount, db *gorm.DB) (*AbonnementAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AbonnementAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AbonnementAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AbonnementAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementAccount(ctx context.Context, in *AbonnementAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AbonnementAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AbonnementAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementAccountSet(ctx context.Context, in []*AbonnementAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AbonnementAccountORM{})).(AbonnementAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AbonnementAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AbonnementAccountORM{})).(AbonnementAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AbonnementAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AbonnementAccount, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AbonnementAccount, *gorm.DB) error
}

// DefaultStrictUpdateAbonnementAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAbonnementAccount(ctx context.Context, in *AbonnementAccount, db *gorm.DB) (*AbonnementAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAbonnementAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AbonnementAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AbonnementAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAbonnementAccount executes a basic gorm update call with patch behavior
func DefaultPatchAbonnementAccount(ctx context.Context, in *AbonnementAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*AbonnementAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AbonnementAccount
	var err error
	if hook, ok := interface{}(&pbObj).(AbonnementAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAbonnementAccount(ctx, &AbonnementAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AbonnementAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAbonnementAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AbonnementAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAbonnementAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AbonnementAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AbonnementAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AbonnementAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AbonnementAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AbonnementAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AbonnementAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAbonnementAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetAbonnementAccount(ctx context.Context, objects []*AbonnementAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AbonnementAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AbonnementAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAbonnementAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAbonnementAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAbonnementAccount(ctx context.Context, patchee *AbonnementAccount, patcher *AbonnementAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AbonnementAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAbonnement bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AbonnementID" {
			patchee.AbonnementID = patcher.AbonnementID
			continue
		}
		if !updatedAbonnement && strings.HasPrefix(f, prefix+"Abonnement.") {
			updatedAbonnement = true
			if patcher.Abonnement == nil {
				patchee.Abonnement = nil
				continue
			}
			if patchee.Abonnement == nil {
				patchee.Abonnement = &Abonnement{}
			}
			if o, err := DefaultApplyFieldMaskAbonnement(ctx, patchee.Abonnement, patcher.Abonnement, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Abonnement.", db); err != nil {
				return nil, err
			} else {
				patchee.Abonnement = o
			}
			continue
		}
		if f == prefix+"Abonnement" {
			updatedAbonnement = true
			patchee.Abonnement = patcher.Abonnement
			continue
		}
		if f == prefix+"AccountID" {
			patchee.AccountID = patcher.AccountID
			continue
		}
		if f == prefix+"AccountAlias" {
			patchee.AccountAlias = patcher.AccountAlias
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"Order" {
			patchee.Order = patcher.Order
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAbonnementAccount executes a gorm list call
func DefaultListAbonnementAccount(ctx context.Context, db *gorm.DB) ([]*AbonnementAccount, error) {
	in := AbonnementAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AbonnementAccountORM{}, &AbonnementAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AbonnementAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AbonnementAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AbonnementAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AbonnementAccountORM) error
}

// DefaultCreateAbonnementInvoice executes a basic gorm create call
func DefaultCreateAbonnementInvoice(ctx context.Context, in *AbonnementInvoice, db *gorm.DB) (*AbonnementInvoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementInvoiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAbonnementInvoice(ctx context.Context, in *AbonnementInvoice, db *gorm.DB) (*AbonnementInvoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AbonnementInvoiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AbonnementInvoiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AbonnementInvoiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AbonnementInvoiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementInvoice(ctx context.Context, in *AbonnementInvoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AbonnementInvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AbonnementInvoiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAbonnementInvoiceSet(ctx context.Context, in []*AbonnementInvoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AbonnementInvoiceORM{})).(AbonnementInvoiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AbonnementInvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AbonnementInvoiceORM{})).(AbonnementInvoiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AbonnementInvoiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AbonnementInvoice, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AbonnementInvoice, *gorm.DB) error
}

// DefaultStrictUpdateAbonnementInvoice clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAbonnementInvoice(ctx context.Context, in *AbonnementInvoice, db *gorm.DB) (*AbonnementInvoice, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAbonnementInvoice")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AbonnementInvoiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AbonnementInvoiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAbonnementInvoice executes a basic gorm update call with patch behavior
func DefaultPatchAbonnementInvoice(ctx context.Context, in *AbonnementInvoice, updateMask *field_mask.FieldMask, db *gorm.DB) (*AbonnementInvoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AbonnementInvoice
	var err error
	if hook, ok := interface{}(&pbObj).(AbonnementInvoiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAbonnementInvoice(ctx, &AbonnementInvoice{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AbonnementInvoiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAbonnementInvoice(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AbonnementInvoiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAbonnementInvoice(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AbonnementInvoiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AbonnementInvoiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AbonnementInvoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AbonnementInvoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AbonnementInvoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AbonnementInvoice, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAbonnementInvoice executes a bulk gorm update call with patch behavior
func DefaultPatchSetAbonnementInvoice(ctx context.Context, objects []*AbonnementInvoice, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AbonnementInvoice, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AbonnementInvoice, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAbonnementInvoice(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAbonnementInvoice patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAbonnementInvoice(ctx context.Context, patchee *AbonnementInvoice, patcher *AbonnementInvoice, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AbonnementInvoice, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAbonnement bool
	var updatedDeadlineDate bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"InvoiceCode" {
			patchee.InvoiceCode = patcher.InvoiceCode
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AbonnementID" {
			patchee.AbonnementID = patcher.AbonnementID
			continue
		}
		if !updatedAbonnement && strings.HasPrefix(f, prefix+"Abonnement.") {
			updatedAbonnement = true
			if patcher.Abonnement == nil {
				patchee.Abonnement = nil
				continue
			}
			if patchee.Abonnement == nil {
				patchee.Abonnement = &Abonnement{}
			}
			if o, err := DefaultApplyFieldMaskAbonnement(ctx, patchee.Abonnement, patcher.Abonnement, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Abonnement.", db); err != nil {
				return nil, err
			} else {
				patchee.Abonnement = o
			}
			continue
		}
		if f == prefix+"Abonnement" {
			updatedAbonnement = true
			patchee.Abonnement = patcher.Abonnement
			continue
		}
		if f == prefix+"PeriodCode" {
			patchee.PeriodCode = patcher.PeriodCode
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedDeadlineDate && strings.HasPrefix(f, prefix+"DeadlineDate.") {
			if patcher.DeadlineDate == nil {
				patchee.DeadlineDate = nil
				continue
			}
			if patchee.DeadlineDate == nil {
				patchee.DeadlineDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeadlineDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeadlineDate, patchee.DeadlineDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeadlineDate" {
			updatedDeadlineDate = true
			patchee.DeadlineDate = patcher.DeadlineDate
			continue
		}
		if f == prefix+"AccountID" {
			patchee.AccountID = patcher.AccountID
			continue
		}
		if f == prefix+"AccountAlias" {
			patchee.AccountAlias = patcher.AccountAlias
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAbonnementInvoice executes a gorm list call
func DefaultListAbonnementInvoice(ctx context.Context, db *gorm.DB) ([]*AbonnementInvoice, error) {
	in := AbonnementInvoice{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AbonnementInvoiceORM{}, &AbonnementInvoice{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AbonnementInvoiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AbonnementInvoiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AbonnementInvoice{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AbonnementInvoiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AbonnementInvoiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AbonnementInvoiceORM) error
}

// DefaultCreateCustomAbonnement executes a basic gorm create call
func DefaultCreateCustomAbonnement(ctx context.Context, in *CustomAbonnement, db *gorm.DB) (*CustomAbonnement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CustomAbonnementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCustomAbonnement(ctx context.Context, in *CustomAbonnement, db *gorm.DB) (*CustomAbonnement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CustomAbonnementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CustomAbonnementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CustomAbonnementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CustomAbonnementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCustomAbonnement(ctx context.Context, in *CustomAbonnement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CustomAbonnementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CustomAbonnementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCustomAbonnementSet(ctx context.Context, in []*CustomAbonnement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CustomAbonnementORM{})).(CustomAbonnementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CustomAbonnementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CustomAbonnementORM{})).(CustomAbonnementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CustomAbonnementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CustomAbonnement, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CustomAbonnement, *gorm.DB) error
}

// DefaultStrictUpdateCustomAbonnement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCustomAbonnement(ctx context.Context, in *CustomAbonnement, db *gorm.DB) (*CustomAbonnement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCustomAbonnement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CustomAbonnementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CustomAbonnementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCustomAbonnement executes a basic gorm update call with patch behavior
func DefaultPatchCustomAbonnement(ctx context.Context, in *CustomAbonnement, updateMask *field_mask.FieldMask, db *gorm.DB) (*CustomAbonnement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CustomAbonnement
	var err error
	if hook, ok := interface{}(&pbObj).(CustomAbonnementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCustomAbonnement(ctx, &CustomAbonnement{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CustomAbonnementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCustomAbonnement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CustomAbonnementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCustomAbonnement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CustomAbonnementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CustomAbonnementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CustomAbonnement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CustomAbonnement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CustomAbonnement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CustomAbonnement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCustomAbonnement executes a bulk gorm update call with patch behavior
func DefaultPatchSetCustomAbonnement(ctx context.Context, objects []*CustomAbonnement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CustomAbonnement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CustomAbonnement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCustomAbonnement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCustomAbonnement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCustomAbonnement(ctx context.Context, patchee *CustomAbonnement, patcher *CustomAbonnement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CustomAbonnement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAbonnement bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"AbonnementID" {
			patchee.AbonnementID = patcher.AbonnementID
			continue
		}
		if !updatedAbonnement && strings.HasPrefix(f, prefix+"Abonnement.") {
			updatedAbonnement = true
			if patcher.Abonnement == nil {
				patchee.Abonnement = nil
				continue
			}
			if patchee.Abonnement == nil {
				patchee.Abonnement = &Abonnement{}
			}
			if o, err := DefaultApplyFieldMaskAbonnement(ctx, patchee.Abonnement, patcher.Abonnement, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Abonnement.", db); err != nil {
				return nil, err
			} else {
				patchee.Abonnement = o
			}
			continue
		}
		if f == prefix+"Abonnement" {
			updatedAbonnement = true
			patchee.Abonnement = patcher.Abonnement
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCustomAbonnement executes a gorm list call
func DefaultListCustomAbonnement(ctx context.Context, db *gorm.DB) ([]*CustomAbonnement, error) {
	in := CustomAbonnement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CustomAbonnementORM{}, &CustomAbonnement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CustomAbonnementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CustomAbonnementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CustomAbonnement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CustomAbonnementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CustomAbonnementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CustomAbonnementORM) error
}
